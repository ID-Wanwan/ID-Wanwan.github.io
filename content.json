{"meta":{"title":"Wanwan","subtitle":"","description":"","author":"Wanwan","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"计算机网络知识点总结","slug":"计算机网络知识点总结","date":"2019-11-09T10:52:47.000Z","updated":"2019-11-10T09:38:42.790Z","comments":true,"path":"2019/11/09/计算机网络知识点总结/","link":"","permalink":"http://yoursite.com/2019/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"前言&nbsp;&nbsp;&nbsp;&nbsp; 在 Java 开发计算机网络部分的知识中，最重要的就是 TCP/IP 协议栈，本文将从 TCP/IP 协议体系的认知开始，详细讲解四层模型的各大协议及相关知识，突破面试。","text":"前言&nbsp;&nbsp;&nbsp;&nbsp; 在 Java 开发计算机网络部分的知识中，最重要的就是 TCP/IP 协议栈，本文将从 TCP/IP 协议体系的认知开始，详细讲解四层模型的各大协议及相关知识，突破面试。 参考书籍 TCP/IP 详解 卷1：协议 计算机网络：自顶而下方法 TCP/IP 协议体系的认知 OSI 协议体系：OSI 协议按照功能不同，将互联网自下而上分成七层模型。 物理层：利用传输介质，为数据链路层提供物理连接。 传送内容为01序列的比特流，传输介质可以是光缆、电缆、双绞线、无线电波。 数据交换设备：集线器、中继器。 数据链路层：对物理层的电信号进行分组，解决两个相邻结点之间的通信问题，为网络层提供服务。 传送的协议数据单元： 数据帧。 数据交换设备： 网桥：将两个 LAN 连起来，根据 MAC 地址转发帧。 交换机：识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。 网络层：解决如何使数据包通过各结点传输的问题，即通过 路由选择算法 将数据包送往目的地，为传输层提供服务。 传送的协议数据单元： 数据包 或 分组。 数据交换设备： 路由器：路由转发、存储转发。 交换机 传输层：为上层协议提供 端到端 的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。 传送的协议数据单元：段。 数据交换设备：网关，在传输层以上实现网络互连，仅用于两个高层协议不同的网络互连，可以是局域网，也可以是广域网。 会话层：管理和协调不同主机上何种进程之间的通信(对话)，即负责建立、管理和中止应用程序之间的会话。 表示层：处理流经节点的数据编码的表示问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。 应用层：通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。是用户和网络的接口。 TCP/IP 协议体系： TCP/IP 协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层、应用层。每一层都用若干协议来实现不同的功能，上层协议使用下层协议提供的服务。 数据链路层：负责帧数据的传递，经过数据链路层封装的数据称为帧。 常用协议：ARP协议(地址解析协议)、RARP协议(反向地址解析协议)。 网络层：负责数据传递的方式，实现数据包的选路和转发。 常用协议：IP协议、ICMP协议。 传输层：负责传递数据的控制(准确性、安全性)，为两台主机上的应用程序提供 端到端 的通信，不在乎数据包的中转过程。 常用协议：TCP协议、UDP协议。 应用层：负责数据的展示和获取，如文件传输、名称查询和网络管理等。 常用协议：DNS协议、FTP协议、HTTP协议、HTTPS协议。 数据链路层&nbsp;&nbsp;&nbsp;&nbsp; 数据链路层，在物理层所提供的服务的基础上向网络层提供服务，即将原始的、有差错的物理线路改进成为逻辑上无差错的数据链路，从而向网络层提供高质量的服务。它一般包括 3 种基本服务：无确定的无连接服务、有确定的有连接服务、有确定的无连接服务（不存在无确定的有连接服务）。 以太网帧格式&nbsp;&nbsp;&nbsp;&nbsp; 以太网，是一种计算机局域网技术。IEEE 组织的 IEEE 802.3 标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。它采用 CSMA/CD 媒体接入方法，即带冲突检测的载波侦听多路接入，速率为 10 Mb/s，地址为 48 bit。分为 经典以太网 和 交换式以太网 两大类。 &nbsp;&nbsp;&nbsp;&nbsp; 由于以太网有很多标准，其数据帧格式也有很多，所以这里以 IEEE 802.3 标准来解析以太网帧格式。 字段 字段长度(字节) 说明 前导码(Preamble) 7 同步 帧开始符(SFD) 1 表名下一个字节为目的 MAC 字段 目的地址(DA) 6 目的设备的 MAC 物理地址 源地址(SA) 6 发送设备的 MAC 地址 长度/类型(Length/Type) 2 帧数据字段从长度 / 帧协议类型 数据及填充(data and pad) 46 ~ 1500 帧数据字段，来自高层数据 帧校验序列(FCS) 4 帧数据校验字段，若发生错误，则丢弃此帧 MTU 最大传输单元&nbsp;&nbsp;&nbsp;&nbsp; 以太网帧格式中，帧数据字段的长度被称为最大传输单元，即 MTU。它是指在传输数据过程中允许报文的最大长度，1500字节。 MTU 对 IP协议 的影响（1）IP报文在超过 MTU 之后需要分片，接收端需要组装。（2）分片若丢失，则接收端会组装失败，IP报文相当于传输失败，但IP协议不负责重新传输数据。（3）由于分片，会加大IP报文丢失的可能性。（4）报文的分片和组装由 IP层 独自完成，加大传输成本，降低性能。 MTU 对 UDP协议 的影响（1）UDP协议的报头为固定的 20 字节。（2）若 UDP 数据的长度超过 (1500 - 20) 1480 字节，则数据会在网络层分片。（3）数据的分片会加大数据丢失的可能性。 MTU 对 TCP协议 的影响（1）TCP协议的报头为 20 - 60 字节。（2）若 TCP 报文的总长度超过 1500 字节，则数据同样在网络层会分片。（3）数据分片会加大数据对视的可能性，TCP协议的可靠性降低。 &nbsp;&nbsp; 即由于MTU的存在，对于传输报文长度有限制而导致的分片，会增加数据丢包的可能性，也会降低数据传输的性能，所以在网络中传输数据时尽量将数据的大小控制在不造成分片的最大长度。 ARP 协议&nbsp;&nbsp;&nbsp;&nbsp; ARP协议是 地址解析协议 的缩写，由于在以太网环境中，数据传输所依赖的是 MAC 地址而不是 IP 地址，所以将已知 IP地址 转化为 MAC地址 的工作由 ARP 协议完成。 MAC地址 ：网络中每台设备都有一个唯一的网络标识，这个地址叫 MAC 地址，48 bit，表示为12个16进制数。 ARP 报文格式ARP的请求和应答都是依赖 ARP报文 结构进行的，它放在以太网数据帧中进行发送，下面是 ARP报文 的格式。 其在以太网帧结构里封装的格式又为，即以太帧的数据区是ARP请求或响应的报文： 在ARP表建立之前，主机并不知道目标的 MAC 地址，所以一开始时只能通过广播的方式将 ARP请求包 发送出去，处于统一局域网的主机都能接收到广播的数据包。 ARP 缓存&nbsp;&nbsp;&nbsp;&nbsp; ARP缓存是一个缓冲区，用来存储 IP地址到MAC地址的映射关系 ，每台主机或路由器都在维护着一个ARP缓存表。本质是 &lt;IP, MAC&gt;的对应表，表中一条记录就是网络上一个主机的 IP地址 和其对应的 MAC地址，我们称之为 ARP表项。 ARP缓存表包含一个 寿命值 TTL，也称作生存时间，它将记录每个 ARP表项的生存时间。生存时间到了就会从缓存表中删除。 当地址解析协议被询问一个已知 IP地址 结点的 MAC地址 时，先在 ARP缓存 中查看，存在则直接返回对应的 MAC地址；不存在，才发送 ARP 请求向局域网查询。 ARP 协议解析过程(查询过程) 每台主机都在自己的 ARP缓冲区 ，建立 ARP缓存表，表示IP地址和MAC地址的对应关系。源主机需要发送数据包时，先在 ARP缓存表 中查询，存在则发送，不存在则在局域网内发起 ARP请求 的广播包查询该 MAC地址。 网络中的 所有主机 收到ARP请求后，检查数据包中的IP地址是否和自己的IP地址一致，不相同忽略该数据包；相同则将 发送端的MAC地址和IP地址 添加到自己的ARP缓存表中，已存在则覆盖，然后向 源主机 发送一个 ARP响应包，告诉它本机的MAC地址。 源主机收到该响应数据包，将 目的主机的MAC地址和IP地址 添加到自己的ARP缓存表中，并利用该信息进行数据传输。如果源主机 没有收到ARP响应数据包，则表示查询失败。 RARP 协议&nbsp;&nbsp;&nbsp;&nbsp; RARP协议，又称反向地址转换协议，可以理解为ARP协议的逆过程，即 将MAC地址转化为IP地址。RARP分组的格式和ARP分组基本一致，工作流程也基本一致，这里就不再详细叙述。 面试题总结 问题1：ARP的作用？答：ARP可以将 IP地址 转化为 MAC地址，即为IP地址到对应的硬件地址提供 动态映射。 问题2：点对点链路使用ARP吗？答：不使用，因为点对点链路的通信双方 已获知彼此的IP地址，不需要ARP协议进行转换。 问题3：ARP高效运行的关键是？答：每台主机都维护着一张 ARP缓存表，ARP地址解析时首先查看的是本主机的 ARP缓存表，发现没有时，再向局域网内广播查询。 问题4：ARP报文的各个字段及含义？答：字段如ARP报文结构图，共28字节，记忆方法：以太网先目的后源，ARP先发送端后目的端，先硬件后协议。 问题5：ARP协议有什么弱点？答：（1）缓存：主机的地址映射是基于缓存表，动态更新的，而地址刷新有 时间限制。可以通过下次更新之前修改计算机的地址缓存，造成 DDos攻击 或 ARP欺骗。（2）广播：攻击者可以伪装 ARP应答。（3）ARP应答没有认证，都是合法的。可以在不接受请求的时候就发出应答包。 问题6：ARP代理的概念和应用场景答：ARP代理：若ARP请求是从一个网络的主机，发送到 另一个网络的主机，那么连接这个两个网络的路由器就可以回答该请求，该过程是ARP代理。ARP代理路由器响应ARP请求的MAC地址为 路由器的MAC地址，而不是ARP请求主机的MAC地址。应用场景：两个物理网络之间的路由，使用相等的网络号，两个路由器使用 ARP 代理，实现相互隐瞒物理网络。 问题7：免费ARP是什么？答：免费ARP：指主机发送 ARP 查找 自己的IP地址，即数据链路层 SIP = DIP。作用：（1）确定是否有其他主机设置了与本机相同的IP地址。（2）如果本机更改MAC地址，可以告知其他主机更新ARP缓存表。 网络层&nbsp;&nbsp;&nbsp;&nbsp; 网络层实现数据包的选路和转发。WAN(广域网) 通常使用众多分级的路由器来连接分散的主机或 LAN(局域网)，因此，通讯的两台主机 一般不是直接相连的，二是通过多个中间结点 (路由器)连接。网络层的任务就是选择这些中间结点，确定两台主机之间的通讯路径。 IP 协议&nbsp;&nbsp;&nbsp;&nbsp; IP协议是 TCP/IP协议族 的核心协议，主要包含两个方面： 1. IP首部格式。 2. IP数据报的路由和转发，即IP选路的实现。 它为上层提供 无状态、无连接、不可靠 的服务。 无状态：指IP通信双方 不同步传输数据的状态信息，因此所有IP数据报的发送、传输、接收都是相互独立的。 优点：简单、高效，通信时无需分配过多资源。 缺点：无法处理乱序、重复的IP数据报。 无连接：指IP通信双方都 不长久地维持双方任何信息，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。 不可靠：指IP协议 不能保证IP数据报准确地到达接收端，很多情况都可以导致IP数据报发送失败，而且IP协议不负责重新传输。因此，使用IP服务的上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。 IP 报文首部格式&nbsp;&nbsp;&nbsp;&nbsp; 深入剖析IP协议，大部分时间都是深入剖析IP头部协议，因此IP协议可以分为 IPv4 和 IPv6 两大版本来进行分析。 IPv4&nbsp;&nbsp;&nbsp;&nbsp; IPv4中规定IP地址长度为 32， 可提供 $2^{32}$ 个地址，目前已快耗尽。使用地址解析协议 ARP ，其报文首部由 固定部分(20字节) + 可变部分 组成，格式如下，涂色部分需要重点理解： table th:last-of-type { width: 700px; } 字段 位数 描述 版本号 4 通信协议的版本，通信双方的IP协议 必须一致 首部长度 4 在IPv4中规定地址长度为32位(4字节)，IP首部固定20字节，所以4位最大值1111(15)×4 = 60字节。即：IP首部最长60字节，最短20字节。首部长度是 4 字节的整数倍，会自动补齐 服务类型 8 无用，自动占8位 总长度 16 IP数据报 首部 + 数据 的字节总长度。最大值 $2^{16}-1 = 65535$，超出部分会分片 标识 16 IP在存储器中的 IP数据报计数器，每产生一个IP数据报，计数器+1并赋值给标识字段。分片时标识统一复制，重组时相同标识的IP数据报合并 标志 3 一般高两位有用。高位 MF：MF=1，表示后续仍有分片，MF=0，表示这是最后一份分片。中间位 DF：DF 表示 不能分片，DF=0才能分片 片偏移 13 分片后，该片在原分组的相对位置，实际偏移为偏移量左移3位(乘8)后得到。基本单位是 8 字节，即每个分片长度是 8 字节整数倍，不够填充 生存时间 TTL 8 即数据报可以经过路由器的数量，最大值位 $2^{8}-1=255$个 协议 8 区分上层协议，ICMP是1，TCP是6，UDP是17 首部校验和 16 发送端：校验和置0，其他首部数据 反码相加，结果放入校验和；接收端：首部数据和校验和 一起反码相加，结果为0保留数据报，否则丢弃 IP 源地址 32 将网络字节顺序转化位主机字节顺序，即：每4字节，1&lt;-&gt;4，2&lt;-&gt;3，互换 目的地址 32 转换方法和源IP地址一样 IPv6&nbsp;&nbsp;&nbsp;&nbsp; 和 IPv4 相比，IPv6 将原来的 32 位地址空间增大到 128 位，即可以指定 $2^{128}$ 个地址。使用 多点传播 Neighbor Solicitation 消息 取代 ARP 协议，其首部格式变更如下： IPv6首部 IPv4首部 位数 描述 版本 版本 4 IP协议的版本，IPv4为4，IPv6为6 通信量类 服务类型 8 无用，自动占8位 流标号 无 20 准备用于服务质量控制，且 流标号、源地址、目的地址完全一致，才认为是一个流 有效载荷长度 总长度 16 IPv6的 扩展首部 + 数据 长度，即有效载荷长度 下一个首部 协议 8 区分上层协议，通常为TCP或UDP。有扩展首部时，表示第一个扩展首部的协议类型 跳数限制 生存时间TTL 8 IP数据报可经过路由的数量，最大为 255 个 首部长度 首部长度 0 IPv6基本首部长度 固定为40字节 扩展首部 标识，标志，片偏移 0 IPv6中将这三个字段移至扩展首部中 可选字段 可选字段 0 功能归并在扩展首部 首部校验和 首部校验和 0 取消首部校验，加快路由器对数据报的处理速度。在数据链路层，发现差错的帧直接抛弃；运输层中，TCP发现差错会重传，UDP发现差错会抛弃。 IP 分片&nbsp;&nbsp;&nbsp;&nbsp; 当IP数据报的长度超过帧的 MTU 时，它将被分片传输。分片可能发生在传输过程的任何一个结点，只有在目的主机上才会将分片重组。&nbsp;&nbsp;&nbsp;&nbsp; 无论是IPv4协议还是IPv6协议，都在IP首部中提供了IP分片和重组的信息字段：数据报标识、标志、片偏移。 书签TCP/IP协议族体系结构ARP协议详解数据链路层：ARP协议详解（绝对经典）IP协议详解IP协议详解(一)","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络校招知识点总结","slug":"计算机网络校招知识点总结","date":"2019-11-09T03:00:30.000Z","updated":"2019-11-09T10:54:47.847Z","comments":true,"path":"2019/11/09/计算机网络校招知识点总结/","link":"","permalink":"http://yoursite.com/2019/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A0%A1%E6%8B%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"前言&nbsp;&nbsp;&nbsp;&nbsp; 在 Java 开发计算机网络部分的知识中，最重要的就是 TCP/IP 协议栈，本文将从 TCP/IP 协议体系的认知开始，详细讲解四层模型的各大协议及相关知识，突破面试。","text":"前言&nbsp;&nbsp;&nbsp;&nbsp; 在 Java 开发计算机网络部分的知识中，最重要的就是 TCP/IP 协议栈，本文将从 TCP/IP 协议体系的认知开始，详细讲解四层模型的各大协议及相关知识，突破面试。 参考书籍 TCP/IP 详解 卷1：协议 计算机网络：自顶而下方法 TCP/IP 协议体系的认知 OSI 协议体系：OSI 协议按照功能不同，将互联网自下而上分成七层模型。 物理层：利用传输介质，为数据链路层提供物理连接。 传送内容为01序列的比特流，传输介质可以是光缆、电缆、双绞线、无线电波。 数据交换设备：集线器、中继器。 数据链路层：对物理层的电信号进行分组，解决两个相邻结点之间的通信问题，为网络层提供服务。 传送的协议数据单元： 数据帧。 数据交换设备： 网桥：将两个 LAN 连起来，根据 MAC 地址转发帧。 交换机：识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。 网络层：解决如何使数据包通过各结点传输的问题，即通过 路由选择算法 将数据包送往目的地，为传输层提供服务。 传送的协议数据单元： 数据包 或 分组。 数据交换设备： 路由器：路由转发、存储转发。 交换机 传输层：为上层协议提供 端到端 的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。 传送的协议数据单元：段。 数据交换设备：网关，在传输层以上实现网络互连，仅用于两个高层协议不同的网络互连，可以是局域网，也可以是广域网。 会话层：管理和协调不同主机上何种进程之间的通信(对话)，即负责建立、管理和中止应用程序之间的会话。 表示层：处理流经节点的数据编码的表示问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。 应用层：通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。是用户和网络的接口。 2. TCP/IP 协议体系： TCP/IP 协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层、应用层。每一层都用若干协议来实现不同的功能，上层协议使用下层协议提供的服务。 数据链路层：负责帧数据的传递，经过数据链路层封装的数据称为帧。 常用协议：ARP协议(地址解析协议)、RARP协议(反向地址解析协议)。 网络层：负责数据传递的方式，实现数据包的选路和转发。 常用协议：IP协议、ICMP协议。 传输层：负责传递数据的控制(准确性、安全性)，为两台主机上的应用程序提供 端到端 的通信，不在乎数据包的中转过程。 常用协议：TCP协议、UDP协议。 应用层：负责数据的展示和获取，如文件传输、名称查询和网络管理等。 常用协议：DNS协议、FTP协议、HTTP协议、HTTPS协议。 数据链路层&nbsp;&nbsp;&nbsp;&nbsp; 数据链路层，在物理层所提供的服务的基础上向网络层提供服务，即将原始的、有差错的物理线路改进成为逻辑上无差错的数据链路，从而向网络层提供高质量的服务。它一般包括 3 种基本服务：无确定的无连接服务、有确定的有连接服务、有确定的无连接服务（不存在无确定的有连接服务）。 以太网帧格式&nbsp;&nbsp;&nbsp;&nbsp; 以太网，是一种计算机局域网技术。IEEE 组织的 IEEE 802.3 标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。它采用 CSMA/CD 媒体接入方法，即带冲突检测的载波侦听多路接入，速率为 10 Mb/s，地址为 48 bit。分为 经典以太网 和 交换式以太网 两大类。 &nbsp;&nbsp;&nbsp;&nbsp; 由于以太网有很多标准，其数据帧格式也有很多，所以这里以 IEEE 802.3 标准来解析以太网帧格式。 字段 字段长度(字节) 说明 前导码(Preamble) 7 同步 帧开始符(SFD) 1 表名下一个字节为目的 MAC 字段 目的地址(DA) 6 目的设备的 MAC 物理地址 源地址(SA) 6 发送设备的 MAC 地址 长度/类型(Length/Type) 2 帧数据字段从长度 / 帧协议类型 数据及填充(data and pad) 46 ~ 1500 帧数据字段，来自高层数据 帧校验序列(FCS) 4 帧数据校验字段，若发生错误，则丢弃此帧 MTU 最大传输单元&nbsp;&nbsp;&nbsp;&nbsp; 以太网帧格式中，帧数据字段的长度被称为最大传输单元，即 MTU。它是指在传输数据过程中允许报文的最大长度，1500字节。 MTU 对 IP协议 的影响（1）IP报文在超过 MTU 之后需要分片，接收端需要组装。（2）分片若丢失，则接收端会组装失败，IP报文相当于传输失败，但IP协议不负责重新传输数据。（3）由于分片，会加大IP报文丢失的可能性。（4）报文的分片和组装由 IP层 独自完成，加大传输成本，降低性能。 MTU 对 UDP协议 的影响（1）UDP协议的报头为固定的 20 字节。（2）若 UDP 数据的长度超过 (1500 - 20) 1480 字节，则数据会在网络层分片。（3）数据的分片会加大数据丢失的可能性。 MTU 对 TCP协议 的影响（1）TCP协议的报头为 20 - 60 字节。（2）若 TCP 报文的总长度超过 1500 字节，则数据同样在网络层会分片。（3）数据分片会加大数据对视的可能性，TCP协议的可靠性降低。 &nbsp;&nbsp; 即由于MTU的存在，对于传输报文长度有限制而导致的分片，会增加数据丢包的可能性，也会降低数据传输的性能，所以在网络中传输数据时尽量将数据的大小控制在不造成分片的最大长度。 ARP 协议&nbsp;&nbsp;&nbsp;&nbsp; ARP协议是 地址解析协议 的缩写，由于在以太网环境中，数据传输所依赖的是 MAC 地址而不是 IP 地址，所以将已知 IP地址 转化为 MAC地址 的工作由 ARP 协议完成。 MAC地址 ：网络中每台设备都有一个唯一的网络标识，这个地址叫 MAC 地址，48 bit，表示为12个16进制数。 ARP 报文格式ARP的请求和应答都是依赖 ARP报文 结构进行的，它放在以太网数据帧中进行发送，下面是 ARP报文 的格式。","categories":[],"tags":[]},{"title":"Java自学路线及书籍推荐","slug":"Java自学路线及书籍推荐","date":"2019-11-05T07:12:17.000Z","updated":"2019-11-05T07:12:32.051Z","comments":true,"path":"2019/11/05/Java自学路线及书籍推荐/","link":"","permalink":"http://yoursite.com/2019/11/05/Java%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF%E5%8F%8A%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/","excerpt":"基础知识 编程语言：Java Java编程思想， Python， C 基本算法 基本网络知识：TCP/IP， HTTP/HTTPS。 TCP/IP 详解 基本设计模式","text":"基础知识 编程语言：Java Java编程思想， Python， C 基本算法 基本网络知识：TCP/IP， HTTP/HTTPS。 TCP/IP 详解 基本设计模式 工具 操作系统：Linux(CentOS\\Ubuntu\\Fedora) 代码管理：SVN / Git 持续集成(CI/CD)：jenkins Java项目管理工具：Maven / Gradle 框架方面应用层框架 SSH：Spring + Structs + Hibernate，已过时不建议学 SSM：Spring + SpringMVC + Mybatis。 JavaEE框架整合开发入门到实战，这本书讲究入门使用，原理讲的并不深入。 Spring Boot 中间件 MQ 消息队列 RPC 通信框架：gRPC thrift dubbo SpringCloud ElasticSearch 数据库 搜索引擎 数据库 SQL：MySQL / Postgre SQL NoSQL：Redis Memcached MongoDB 架构方面分布式 / 微服务架构 Spring Cloud Dubbo RPC 通信框架 虚拟化 / 容器化技术 Docker 容器化 K8S：kubernetes 关注源码 / 性能 JDK 源码以及部分设计思想 Spring 源码 JVM 细节与排错：深入理解Java虚拟机 高并发 / 高可用：Java并发编程实战，Java并发编程的艺术","categories":[],"tags":[]},{"title":"Windows系统下Hexo博客搭建","slug":"Windows系统下Hexo博客搭建","date":"2019-11-05T03:50:26.000Z","updated":"2019-11-05T03:52:32.633Z","comments":true,"path":"2019/11/05/Windows系统下Hexo博客搭建/","link":"","permalink":"http://yoursite.com/2019/11/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"前言Hexo 使一个快速简洁的博客框架，可以非常容易搭建起自己的博客，在平时学习工作中便于及时记录知识要点并分享。本文将记录 Windows 系统下 Hexo 博客搭建的流程，帮助更多人搭建个人博客。","text":"前言Hexo 使一个快速简洁的博客框架，可以非常容易搭建起自己的博客，在平时学习工作中便于及时记录知识要点并分享。本文将记录 Windows 系统下 Hexo 博客搭建的流程，帮助更多人搭建个人博客。 Hexo 搭建步骤 安装 Node.js 安装 Git 安装 Hexo 在 Github 中创建个人仓库 将 Hexo 部署到 Github 发布文章 更换 Hexo 主题 安装 Node.js在 Node.js 官网，可以下载到最新版本，当前是 12.13.0。具体安装教程可以参考 Node.js安装及环境配置之Windows篇，需要特别注意环境变量的设置。 安装 Git同样在 Git 官网的下载页面，可以下载 Linux、Windows、mac OS 三个版本的安装包，点击 windows 下载，安装在本地磁盘中。安装完成，点击鼠标右键，若出现 Git GUI Here 和 Git Bash Here，则下载安装成功。后续操作全部在 Git Bash 下执行。 安装 Hexo 首先在任意磁盘新建文件夹 MyBlog，用来统一管理博客。然后在该文件夹下打开 Git Bash，使用命令安装 Hexo，并检查是否安装成功。12npm i -g hexo # 安装 hexohexo -v # 检查 hexo 的版本 启动 Hexo 本地服务，可以得知服务运行在 http://localhost:4000 上，我们可以通过该网址在本地访问博客。1hexo s 创建一篇博客，文章保存在 /MyBlog/source/_posts，博客内容使用 Markdown 语法编写，这里推荐一款专门编写 Hexo 博客的编辑器 HexoEditor，源项目 可以在 Github 上查看，也可以 直接下载 发布版本。1hexo n &quot;文章名称&quot; 博客编辑完成后，退回至 /MyBlog 文件夹下，使用命令 清空 缓存文件和已经生成的静态文件，然后生成静态文件，从本地进行访问。12hexo clean # 清空缓存hexo g # 生成静态文件 在 Github 中创建个人仓库 首先在 Github 上创建一个新仓库，以如下格式命名：12&quot;GitHub_ID&quot;.github.io # 命名格式ID-Wanwan.github.io # 我的github id是 ID-Wanwan， 现在需要将本地博客与 Github 建立关联。在根目录 /MyBlog 下打开 Git Bash，安装插件 hexo-deployer-git。1npm install hexo-deployer-git --save 根目录中有博客配置文件 _config.yml，用文本编辑器打开配置文件，在 # Deployment 下的 deploy 属性中添加如下内容：1234deploy: type: git repo: https://github.com/ID-Wanwan/ID-Wanwan.github.io.git branch: master 其中 repo 是步骤1中 新建仓库的地址 ，后面再加上 .git 即可。到此本地博客就与 Github 建立了关联，可以进行下一步部署。 将 Hexo 部署在 Github 上 输入部署命令： 1hexo d 发现出现 Erroe: Spawn failed，根据提示，发现需要设置 Github 的邮箱和用户名信息，来帮助辨认身份并登录到远端的个人仓库。 12git config --global user.email &quot;you@example.com&quot; # 设置 Github 邮箱git config --global user.name &quot;Your Name&quot; # 设置 Github 用户名 重新设置完成后，再次输入部署命令 hexo d，然后输入账号密码登录 Github 。 若运行过程中发现如下错误： 1error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 根据查阅资料得知，这是安全设置的问题，解决方式如下： 首先执行： git config http.sslVerify &quot;false&quot; 若发现如下错误：fatal：not in a git directory 执行：git config --globle http.sslVerify &quot;false&quot; 经过如上步骤，再次部署博客 hexo d，Github 仓库中就有刚才发布的博客了。 在浏览器中输入 Github 博客仓库的名称，即可远端访问博客，部署完成。 1https://ID-Wanwan.github.io 发布文章 通过 hexo n &quot;文章名称&quot;，创建一篇新的博客，用文本编辑器编辑文章。 在本地预览博客发布后的样式。123hexo clean # 清空缓存 hexo g # 生成静态文件hexo s # 启动本地服务 确认无误后，将博客发布到 Github 平台。1hexo d 更换 Hexo 主题 在 Github 或者 Hexo 官网上寻找自己喜欢的博客主题，这里以在 Github 中下载 yilia 主题为例。在本地博客根目录 /MyBlog 下打开 Git Bash，可以以如下格式下载主题：12git clone 主题链接.git themes/主题文件夹 # 参考格式git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 在 /MyBlog/themes 中可以看到刚才下载好的主题， 退回到根目录 /MyBlog，打开配置文件 _config.yml，在 # Extensions 下更改 theme 的值为主题文件夹的名称。1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 更新设置，在本地预览。123hexo clean # 清空缓存 hexo g # 生成静态文件hexo s # 启动本地服务 确认无误后，部署至 Github 平台，主题更换完成。1hexo d 后记到这里个人博客就已经初步搭建成功，后续可以根据自己的需要更改主题的美化设置，深入探索 Hexo 框架或者其他博客框架的其他内容。 书签HexoEditor 快捷键","categories":[],"tags":[]},{"title":"MySQL","slug":"MySQL","date":"2019-11-04T14:27:07.000Z","updated":"2019-11-04T17:29:22.968Z","comments":true,"path":"2019/11/04/MySQL/","link":"","permalink":"http://yoursite.com/2019/11/04/MySQL/","excerpt":"1. SQL 分类 DDL（Data Definition Language），数据定义语言： 定义数据库对象：数据库、表、列表等。 create、drop、alter等。 DML（Data Manipulation Language），数据操作语言： 对数据库中表的数据进行增删改。insert、delete、update等。 DQL（Data Query Language），数据查询语言： 查询数据库中表的记录（数据)。select、where等。 DCL（Data Control Language），数据控制语言： 定义数据库的访问权限和安全级别，及创建用户。GRANT、REVOKE等。","text":"1. SQL 分类 DDL（Data Definition Language），数据定义语言： 定义数据库对象：数据库、表、列表等。 create、drop、alter等。 DML（Data Manipulation Language），数据操作语言： 对数据库中表的数据进行增删改。insert、delete、update等。 DQL（Data Query Language），数据查询语言： 查询数据库中表的记录（数据)。select、where等。 DCL（Data Control Language），数据控制语言： 定义数据库的访问权限和安全级别，及创建用户。GRANT、REVOKE等。 1.1 DDL：数据定义1.1.1 操作数据库（CRUD） C(Create)：创建 create database 数据库名;：创建数据库（默认字符集 var)。 create database if not exists 数据库名;：创建数据库前，先检测是否从重名，重名不报错会出警告；不重名则创建。 create database 数据库名 character set 字符集名;：创建数据库并指定字符集。 R (Retrieve)：查询 SHOW DATABASES;：查询所有数据库的名称。 show create database 数据库名;：查询某个数据库的字符集（创建语句）。 U (Update)：修改 alter database 数据库名 character set 字符集名;：修改数据库的字符集。 D (Delete)：删除 drop database 数据库名;：删除数据库。 drop database if exists 数据库名;：删除数据库前先判断是否存在，存在才删除。 使用数据库 use 数据库名;：使用数据库。 select database();：查询当前正在使用的数据库。 1.1.2 操作表（CRUD） C(Create)：创建 create table 表名 ( 列名1 数据类型1， # 数据库类型：整数类型、小数类型、日期类型、字符串、 列名2 数据类型2， # 二进制、BLOB、CLOB ... 列名n 数据类型n ); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 ![1570087978757](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570087978757.png) ![1570088223160](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570088223160.png) - `create table 表名1 like 表名2;`：复制表2。![1570088462528](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570088462528.png) 2. R (`Retrieve`)：查询 - `show tables;`：查询某个数据库中所有表的名称。![1570087773216](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570087773216.png) - `desc 表名;`：查询表结构。![1570087781197](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570087781197.png) - `show create table 表名;`：查询表的创建语句。![1570089183036](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089183036.png) 3. U (`Update`)：修改 - `alter table 表名 rename to 新表名;`：修改表名。![1570089011667](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089011667.png) - `alter table 表名 character set 字符集名;`：修改表的字符集。![1570089253870](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089253870.png)![1570089268029](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089268029.png) - `alter table 表名 add 列名 数据类型;`：添加一列。![1570089672862](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089672862.png)![1570089704936](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089704936.png) - `alter table 表名 change 新列名 新数据类型`：修改列名称、类型。![1570089864614](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089864614.png) - `alter table 表名 modify 原列名 新数据类型;`：只修改列名的数据类型。![1570090045012](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570090045012.png) - `alter table 表名 drop 列名`：删除列。![1570090161501](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570090161501.png)4. D (`Delete`)：删除 - `drop table 表名;`：删除表。 - `drop table if exists 表名;`：删除表前先判断是否存在，存在才删除。------## 1.2 **DML**：增改删表中数据### 1.2.1 添加数据- `insert into 表名(列名1, 列名2, ...., 列名n) values(值1, 值2, ..., 值n);`![1570093386552](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570093386552.png)![1570093366484](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570093366484.png)- 注意事项: - 列名与值，需一一对应； - 表名后不添加列名，默认指给所有列添加列名；------### 1.2.2 删除数据- `delete from 表名 [where 条件]`：按条件从表中删除数据。![1570110108818](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110108818.png)![1570110141047](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110141047.png)![1570110160574](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110160574.png)- `delete from 表名;` ：删除表中所有记录，有多少条记录就执行多少次，效率低不推荐。- `TRUNCATE table 表名;`：删除表，然后在创建一个一模一样的空表，推荐使用该方法。------### 1.2.3 修改数据- `update 表名 set 列名1=值1, 列名2=值2, ... [where 条件];`：修改表中记录。![1570110763329](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110763329.png)- `update 表名 set 列名1=值1, 列名2=值2, ...;`：不加条件，修改所有记录。------## 1.3 DQL：查询表中的记录​ `select * from 表名;`：单表查询### 1.3.1 语法```mysqlselect 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定; 1.3.2 基础查询 多字段查询 在 select 后的字段列表中写明想查询的字段即可。如查询姓名与年龄： 1select name, age from student; 去除重复 distinct 关键字可以对查询结果集去重。如查询城市： 1select distinct address from student; -- 查询城市 计算列 将可计算列的字段，在查询字段列表中用算术符号连接即可。如查询数学和英语成绩之和： 1select name,math,english, math + english from student; 注意：如果有 null 参与运算，结果都为 null，MySQL有 IFNULL() 函数来解决该问题。 1select name, math, english, math + IFNULL(english, 0) from student; 即在 english 字段中，如果遇到 null ，就将其替换为 0 参与计算，及如果如下： 起别名 在字段列表中，某个字段后添加 AS 和新名字即可。如将 math + IFNULL(english, 0) 改为 总分 ： 1select name, math, english, math + IFNULL(english, 0) as 总分 from student; 或者 不使用as关键字，直接空格后添加新名字 也能实现改名功能： 1select name, math, english, math + IFNULL(english, 0) 总分 from student; 1.3.3 条件查询 where 子句后跟条件 运算符 比较运算符：&gt;、&lt;、&gt;=、&lt;=、=、&lt;&gt;（不等于）； BETWEEN...AND：在某个*闭区间 *范围内的记录； 12-- 查询年龄在20到50岁之间的人select * from student where age between 20 and 50; IN(集合)：表示多个值，用逗号分隔； 12-- 查询年龄20岁，22岁，55岁的人select * from student where age in (20,22,55); LINK &#39;&#39;：模糊查询； 12-- 查询姓马的人，% 表示之后的任意字符select * FROM student WHERE name LIKE &apos;马%&apos;; 12345-- 查询姓马且名字字数为一个字的人， _ 下划线表示一个占位字符SELECT * FROM student WHERE name LIKE &apos;马_&apos;;-- 查询姓马且名字字数为两个字的人， _ 下划线表示一个占位字符SELECT * FROM student WHERE name LIKE &apos;马__&apos;; ![1570371035533](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570371035533.png)![1570371063776](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570371063776.png) IS NULL：查询某列为 null 的值，不能写=NULL ； 12345-- 查询英语成绩为null的人，不能用运算符进行判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为null的人SELECT * from student WHERE english IS NOT NULL; ) 1.3.4 排序查询 语法：order by 子句 1SELECT * FROM 表名 WHERE 条件子句 ORDER BY 排序字段1 排序方式1, 排序字段2 排序方式2 ... 排序方式： ASC：升序排序，默认方式； DESC：降序排序； 123-- 按照数学成绩升序/降序排序SELECT * FROM student ORDER BY math;SELECT * FROM student ORDER BY math DESC; ) 多字段排序：若某一字段数据相同，则可以按照第二排序字段进行排序。 123-- 按照数学成绩、英语成绩进行升序排序SELECT * FROM student ORDER BY math, english;SELECT * FROM student ORDER BY math ASC, english ASC; 1.3.5 聚合函数​ 聚合函数：将一列数据作为整体，进行纵向计算。 count：计算个数，一般选择非空的列（主键）。 12345678SELECT COUNT(列名) FROM 表名; -- 该函数排除null值-- 计算人数SELECT COUNT(name) FROM student;-- 计算参加英语考试的人数SELECT COUNT(english) FROM student;SELECT COUNT(IFNULL(english, 0)) FROM student; -- 改进如下，将null值算进去 )) max：计算最大值； 12-- 计算数学成绩的最大值SELECT MAX(math) FROM student; min：计算最小值； 12-- 计算数学成绩的最小值SELECT MIN(math) FROM student; sum：计算总和； 12-- 计算数学成绩的总和SELECT SUM(math) FROM student; avg：计算平均值； 12-- 计算英语成绩的平均成绩SELECT AVG(english) FROM student; 1.3.6 分组查询 语法： 1SELECT 分组字段、聚合函数 FROM 表名 GROUP BY 分组字段; 12345-- 按照性别分组，分别查询男、女同学的数学平均分SELECT sex, SUM(math) FROM student GROUP BY sex;-- 按照性别分组，分别查询男、女同学的人数SELECT sex, COUNT(sex) FROM student GROUP BY sex; ) 12-- 按照性别分组，分别查询数学成绩大于70分的男、女同学的人数和平均分SELECT sex, COUNT(sex), AVG(math) FROM student WHERE math &gt; 70 GROUP BY sex; 12-- 按照性别分组，分别查询数学成绩大于70分的男、女同学的人数和平均分，低于70分的不参与分组，分组之后人数大于2人，使用 having 子句进行分组条件限制SELECT sex, COUNT(sex), AVG(math) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(sex) &gt; 2; 注意： 分组之后查询的字段：分组字段、聚合函数； WHERE 和 HAVING 的区别？ WHERE 在分组前进行限定，如果不满足条件，则不参与分组；HAVING 在分组之后进行限定，如果结果不满足条件，则不会被查询到。 WHERE 后不可以跟聚合函数；HAVING 后可以跟聚合函数。 1.3.7 分页查询 语法： 1LIMIT 开始的索引, 每页查询的条数; -- 公式：开始的索引 = (当前页码-1) * 每页条数; 1234-- 每页显示3条记录，分别查询第一页、第二页、第三页SELECT * FROM student LIMIT 0, 3;SELECT * FROM student LIMIT 3, 3;SELECT * FROM student LIMIT 6, 3; )) 不同的数据库实现分页的操作不一样，MySQL中分页操作是 LIMIT 。 1.3.8 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性、完整性。 分类： 主键约束：PRIMARY KEY，该列的值 非空且唯一，一张表 有且只有一个主键，是表中记录的唯一标识。 自动增长：如果某一列的数据类型是 数值型，可以使用 auto_increment 关键字使该值根据上一条数据自动增长，一般与主键一起用。 非空约束：NOT NULL，该列的值不能为空。 唯一约束：UNIQUE，该列的值不能重复。 外键约束：FOREIGN KEY。 添加方式： 在创建表时添加约束： 1234CREATE TABLE stu ( id INT, name VARCHAR(20) 约束名称 -- 约束); 创建完表后添加约束： 1ALTER TABLE student MODIFY name varchar(20) 约束名称; 特殊约束——外键约束：foreign key ，让表与表产生关系，从而保证数据的正确性。 123456789101112131415-- 现添加表如下：create table emp ( id int primary key auto_increment, name varchar(30), age int, dep_name varchar(30), dep_location varchar(30));INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;张三&apos;,20,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;李四&apos;,21,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;王五&apos;,20,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;老王&apos;,20,&apos;销售部&apos;,&apos;深圳&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;大王&apos;,22,&apos;销售部&apos;,&apos;深圳&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;小王&apos;,18,&apos;销售部&apos;,&apos;深圳&apos;); 发现 ‘研发部’,’广州’ 和 ‘销售部’,’深圳’ 有数据冗余，重复多次。 1234567891011121314151617181920212223242526-- 解决方法，将表拆分成两张表：部门表和员工表-- 部门表，主表create table department ( id int PRIMARY KEY auto_increment, dep_name varchar(20), dep_location varchar(20));-- 员工表，从表create table employee ( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 外键对应主表的主键 constraint dep foreign key (dep_id) references department(id));-- 添加两个部门INSERT INTO department VALUES (null,&apos;研发部&apos;,&apos;广州&apos;), (null,&apos;销售部&apos;,&apos;深圳&apos;);-- 添加员工INSERT INTO employee (name, age, dep_id) VALUES (&apos;张三&apos;, 20, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;李四&apos;, 21, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;王五&apos;, 20, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;老王&apos;, 22, 2);INSERT INTO employee (name, age, dep_id) VALUES (&apos;大王&apos;, 20, 2);INSERT INTO employee (name, age, dep_id) VALUES (&apos;小王&apos;, 18, 2); ) 添加外键方式： 在创建表时，可以添加外键。 12345create table 表名 ( ... 外键列, constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)); 删除外键。 1alter table 从表名 drop foreign key 外键名称; 创建表之后，添加外键。 1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称); 级联操作 级联更新 on update cascade：在添加外键时设置，在更改主表主键时，从表的外键会实时更新。 1... on update cascade; 1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称) on update cascade; 级联删除 on delete cascade：在添加外键时设置，在删除主表主键时，从表的外键关联的记录会实时删除。 1... on delete cascade; 1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称) on delete cascade; 2. 数据库设计2.1 多表之间的关系2.1.1 分类 一对一： 人和身份证，一个人只能由一个身份证，一个身份证只对应一个人。 一对多（多对一): 如部门和员工，一个部门有多个员工，而一个员工隶属于一个部门。 多对多： 学生和课程，一个学生可以选择很多课程，一门课程可以被多个学生选择。 2.1.2 实现关系 一对多（多对一）： 部门和员工：一个部门有多个员工，所以 部门(1) —&gt; 员工(n)。 实现方式：在多的一方建立外键，指向一的一方的主键。 多对多： 学生与课程，一个学生可以选多个课程，一门课程可以被多个学生选择，所以 学生(m) —-&gt; 课程(n)。 实现方式：需要第三张中间表，至少包含两个字段作为第三张表的外键，分别指向两张表的主键。 2.1.3 案例​ 某旅游网站，有旅游线路分类、旅游线路、用户信息等功能，建立表存储这些信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-- 创建旅游线路分类表CREATE TABLE tab_category ( cid INT PRIMARY KEY auto_increment, cname VARCHAR (100) NOT NULL UNIQUE);-- 添加旅游线路分类数据INSERT INTO tab_category (cname) VALUES(&apos;周边游&apos;),(&apos;出境游&apos;),(&apos;国内游&apos;),(&apos;港澳游&apos;);-- 创建旅游线路表CREATE TABLE tab_route ( rid INT PRIMARY KEY auto_increment, rname VARCHAR (100) NOT NULL UNIQUE, price DOUBLE, rdate date, cid INT, FOREIGN KEY (cid) REFERENCES tab_category (cid));-- 创建用户表-- uid 用户主键-- username 用户名-- password 密码-- name 真实姓名-- birthday 生日-- sex 性别-- telephone 电话-- email 邮箱CREATE TABLE tab_user ( uid INT PRIMARY KEY auto_increment, username VARCHAR (100) NOT NULL UNIQUE, PASSWORD VARCHAR (30) NOT NULL, NAME VARCHAR (100), birthday date, sex CHAR (1) DEFAULT &apos;男&apos;, telephone VARCHAR (11), email VARCHAR (100));-- 创建收藏表，中间表 关联路线表和用户表CREATE TABLE tab_favorite ( rid INT, date datetime, uid INT, PRIMARY KEY (rid, uid), FOREIGN KEY (rid) REFERENCES tab_route (rid), FOREIGN KEY (uid) REFERENCES tab_user (uid)); 数据库关系如下： 旅游路线分类(1) —&gt; 旅游线路(n) 用户收藏线路(m) —&gt; 旅游线路(n) 2.2 范式概念：设计数据库时，需要遵循的一些规范。 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 其中，第一范式(1NF) ，第二范式(2NF)，第三范式(3NF) 是数据库学习的重点。 2.2.1 第一范式（1NF）​ 每一列都是不可分割的原子数据项。数据库建出来的表都是符合 1NF 的，以下表为例： 第一范式存在问题： 存在严重的 数据冗余 ：姓名、系名、系主任、课程名称； 数据添加 存在问题：添加新开设的系和系主任时，添加的数据不合法； 数据删除 存在问题：删除记录时会将系和系主任数据一起删除； 2.2.2 第二范式（2NF）​ 在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）。 函数依赖：A —&gt; B，如果通过 A 属性的值，可以唯一确定 B 属性的值，则 B 依赖于 A。 例如：学号 —&gt; 姓名，系名 —&gt; 系主任。 完全函数依赖：A —&gt; B，如果 A 是 属性组 ，则 B 属性值的确定需要依赖于 A 属性组中 所有属性的值。 例如：(学号，课程名称) —&gt; 成绩，单学号/课程名称 无法确定成绩。 部分函数依赖：A —&gt; B，如果 A 是 属性组，则 B 属性值的确定仅依赖于 A 属性组中 某些属性值。 例如： (学号，课程名称) —&gt; 姓名，由学号即可确定姓名，不需要课程名称。 传递函数依赖：A —&gt; B，B —&gt; C，如果通过 A 属性的值，可以唯一确定 B 属性的值，通过 B 属性的值，可以唯一确定 C 属性的值，则称 C 传递函数依赖于 A。 例如：学号 —&gt; 姓名，姓名 —&gt; 系名，则 系名 传递依赖于 学号。 ​ 第二范式在 1NF 的基础上，需要对表进行拆分消除部分函数依赖，解决 1NF 存在的问题： 发现第二范式消除部分函数依赖后，仍存在问题： 数据添加 存在问题：添加新开设的系和系主任时，添加的数据不合法； 数据删除 存在问题：删除记录时会将系和系主任数据一起删除； 即，存在函数传递依赖。 2.2.3 第三范式（3NF）​ 在 2NF 的基础上，任何非主属性不依赖于其他非主属性（在 2NF 的基础上消除传递依赖）。 解决方法：在 2NF 基础上再分一张表如下。 上述问题全部解决。 2.3 数据库的备份和还原 命令行 1mysqldump -u用户名 -p密码 数据库名 &gt; 保存路径 -- 备份 还原： 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行sql文件 图形化工具 2.4 多表查询 查询语法： 123456select 列名列表from 表名列表where 条件 例子，准备sql: 1234567891011121314151617181920212223-- 创建部门表CREATE TABLE dept ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));INSERT INTO dept (NAME) VALUES(&apos;开发部&apos;), (&apos;市场部&apos;), (&apos;财务部&apos;);-- 创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1); 直接查询两张表，结果是两张表的 笛卡尔积： 1select * from emp, dept; 2.4.1 内连接查询 隐式内连接：使用 WHERE 条件消除无用数据。 1234-- 查询每个员工的信息及其就职部门SELECT emp.id, emp.name, gender, salary, join_date, dept.nameFROM emp, deptWHERE emp.dept_id = dept.id; 也可以给表取别名，替换复杂的表名来简化查询语句： 1234-- 查询每个员工的信息及其就职部门SELECT t1.id, t1.name, gender, salary, join_date, t2.nameFROM emp t1, dept t2WHERE t1.dept_id = t2.id; 显式内连接：使用 inner join … on 来连接两张表 1select 字段列表 from 表名1 inner join 表名2 on 条件; -- inner 可省略 1234-- 查询每个员工的信息及其就职部门，同样也可以给表名取别名SELECT emp.id, emp.name, gender, salary, join_date, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id; 内连接注意事项： 从哪些表中查询数据； 查询条件是什么； 查询哪些字段； 2.4.2 外连接查询 左外连接：使用 left outer join … on 关键字，查询的是 左表全部数据 和 与右表的交集部分，可以避免连接表时某些记录由于外键不存在，而查询不到。 1select 字段列表 from 表1 left outer join 表2 on 条件; -- outer可省略 上述例子添加一名新员工如下，他没有分配部门。 若直接连接两张表查询所有员工的信息和部门，则该员工会因为 未分配部门 而查询不到，此时需要外连接。 1234-- 查询所有员工的信息和部门，若未分配部门，则该员工部门信息显示 nullSELECT t1.*, t2.nameFROM emp t1 LEFT OUTER JOIN dept t2 -- dept 左外连接 empON t1.dept_id = t2.id; 此时所有员工信息就可正确查询。 右外连接：道理同左外连接，只是查询的是 查询的是 右表全部数据 和 与左表的交集部分。 1select 字段列表 from 表1 right outer join 表2 on 条件; -- outer可省略 1234-- 查询所有员工的信息和部门，若未分配部门，则该员工部门信息显示 nullSELECT t1.*, t2.nameFROM dept t2 RIGHT OUTER JOIN emp t1 -- dept 右外连接 empON t1.dept_id = t2.id; 2.4.3 子查询 概念：查询中 嵌套查询，则嵌套的查询被称为子查询。 语法： 1234567select 字段列表from 表名where 条件1, ( -- ()内是子查询 select 字段列表 from 表名 where 条件) 条件2; 子查询的不同情况 结果是 单行单列 的：子查询可以作为条件，使用运算符（=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;）去判断。如： 12345678910-- 查询工资最高的员工信息-- 1. 查询工资最高是多少-- 2. 查询谁的工资是最高工资SELECT t1.*, t2.nameFROM emp t1, dept t2WHERE t1.dept_id = t2.id AND -- 连表t1.salary = ( -- 查询哪个人的工资等于最大工资 SELECT MAX(salary) -- 查询最大工资 FROM emp t1); 结果是 多行单列 的：子查询可以作为条件，使用运算符 IN 去判断。 123456789-- 查询财务部、市场部所有员工的信息-- 查询财务部、市场部所属的部门编号-- 查询员工信息中，符合这些编号的员工SELECT * FROM empWHERE dept_id IN ( SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 结果是 多行多列 的：子查询可以作为一张 虚拟表。 12345678910111213141516-- 查询入职日期是2011-11-11日之后的员工信息和部门信息-- 查询符合入职日期条件的员工，将其单独存入一张虚拟表-- 将虚拟表与部门信息表连接SELECT t2.*, t1.name FROM dept t1, ( SELECT * FROM emp WHERE join_date &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id;-- 普通内连接也可以实现SELECT t1.*, t2.name FROM emp t1, dept t2WHERE t1.dept_id = t2.id AND t1.join_date &gt; &apos;2011-11-11&apos;; 2.4.4 多表查询练习​ 现有部门表，职位表，员工表，工资表如下： ))) 需求： 查询所有员工信息。查询员工编号、姓名、工资、职务名称、职务描述。 1234-- 查询所有员工信息。查询员工编号、姓名、工资、职务名称、职务描述。SELECT t1.id, ename, salary, jname, descriptionFROM emp t1, job t2WHERE t1.job_id = t2.id; 查询员工编号、姓名、工资、职务名称、职务描述、部门名称、部门位置。 1234-- 查询员工编号、姓名、工资、职务名称、职务描述、部门名称、部门位置。select t1.id, ename, salary, jname, description, dname, locfrom emp t1, job t2, dept t3where t1.job_id = t2.id and t1.dept_id = t3.id; 查询员工姓名、工资、工资等级。 123456789-- 查询员工姓名、工资、工资等级。select t1.ename, t1.salary, t2.gradefrom emp t1, salarygrade t2,WHERE t1.salary BETWEEN t2.losalary AND t2.hisalary; 查询员工姓名、工资、职务名称、职务描述、部门名称、部门位置、工资等级。 1234567891011121314-- 查询员工姓名、工资、职务名称、职务描述、部门名称、部门位置、工资等级。SELECT t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.loc, t4.gradeFROM emp t1, job t2, dept t3, salarygrade t4WHERE t1.job_id = t2.id AND t1.dept_id = t3.id AND t1.salary BETWEEN t4.losalary AND t4.hisalary; 查询部门编号、部门名称、部门位置、部门人数。 123456789101112-- 查询部门编号、部门名称、部门位置、部门人数。SELECT t2.id 部门编号, t2.dname 部门名称, t2.loc 部门位置, COUNT(t1.dept_id) -- 按部门编号统计个数FROM emp t1, dept t2WHERE t1.dept_id = t2.idGROUP BY t1.dept_id; -- 按部门编号分组 查询所有员工的姓名及其直接上级的姓名，没有领导的员工也要查询。 123456789101112-- 查询所有员工的姓名及其直接上级的姓名，没有领导的员工也要查询。SELECT t1.id, t1.ename, t2.id, t2.enameFROM emp t1LEFT JOIN -- 使用左连接，左表是全部员工，右表是直接上级 emp t2ON t1.mgr = t2.id; 3. 事务3.1 事务的基本介绍 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么 同时成功，要么 同时失败。 操作： 开启事务 start transaction： 回滚 rollback： 提交 commit： 现有表如下： 123456789101112131415-- 开启事务START TRANSACTION;-- 转账操作-- 张三账户-500UPDATE account SET balance = balance - 500 WHERE NAME = &apos;张三&apos;;出错了...-- 李四账户+500UPDATE account SET balance = balance + 500 WHERE NAME = &apos;李四&apos;;-- 发现没有问题，提交事务COMMIT;-- 发现出问题，回滚事务，返回到事务开启的时候ROLLBACK; MySql 数据库中事务默认自动提交，一条 DML （增删改）语句会自动提交一次事务。 查看事务的默认提交方式： 1SELECT @@autocommit; -- 1代表自动提交，0代表手动提交 修改事务的默认提交方式： 1SET @@autocommit = 1/0; 3.2 事务的四大特征 原子性：是不可分割的最小操作单位，同时成功 / 同时失败。 持久性：当事务提交 / 回滚后，数据库会发生持久化的保存。 隔离性：多个事务之间，相互独立。 一致性：事务操作前后，数据总量不变。 3.3 事务的隔离级别 (了解) 概念：多个事务之间是隔离的，相互独立。如果多个事务操作同一批数据，会引发一些问题，设置不同的隔离级别可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据。 不可重复读（虚读）：同一个事务中，两次读取到的数据不一致。 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： read uncommitted： 读未提交，会产生上述三种问题。 read committed：（Oracle 默认） 读已提交，解决 脏读 问题。 repeatable read：（MySQL 默认） 可重复度，解决 脏读、不可重复读 问题。 serializable： 串行化，解决 所有问题。 注意：隔离级别从小到大安全性回来越高，效率却越来越低。 数据库隔离级别相关的sql语句： 查询： 12SELECT @@transaction_isolation; -- 查询数据库隔离级别（MySQL8.0以后版本）SELECT @@tx_isolation; -- MySQL 8.0 以前版本 设置： 1set global transaction isolation level 级别字符串; -- 设置数据库隔离级别 脏读案例： 1234-- 数据库隔离级别为 read uncommitted-- 开启两个事务，第一个事务对数据进行修改但不提交，第二个事务可以读取到第一个事务修改后的数据。update account set balance = 500 where id = 1;update account set balance = 1500 where id = 2;","categories":[],"tags":[]}]}