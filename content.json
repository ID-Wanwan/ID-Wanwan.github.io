{"meta":{"title":"Wanwan","subtitle":"","description":"","author":"Wanwan","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Windows系统下Hexo博客搭建","slug":"Windows系统下Hexo博客搭建","date":"2019-11-05T03:50:26.000Z","updated":"2019-11-05T03:52:32.633Z","comments":true,"path":"2019/11/05/Windows系统下Hexo博客搭建/","link":"","permalink":"http://yoursite.com/2019/11/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"前言Hexo 使一个快速简洁的博客框架，可以非常容易搭建起自己的博客，在平时学习工作中便于及时记录知识要点并分享。本文将记录 Windows 系统下 Hexo 博客搭建的流程，帮助更多人搭建个人博客。","text":"前言Hexo 使一个快速简洁的博客框架，可以非常容易搭建起自己的博客，在平时学习工作中便于及时记录知识要点并分享。本文将记录 Windows 系统下 Hexo 博客搭建的流程，帮助更多人搭建个人博客。 Hexo 搭建步骤 安装 Node.js 安装 Git 安装 Hexo 在 Github 中创建个人仓库 将 Hexo 部署到 Github 发布文章 更换 Hexo 主题 安装 Node.js在 Node.js 官网，可以下载到最新版本，当前是 12.13.0。具体安装教程可以参考 Node.js安装及环境配置之Windows篇，需要特别注意环境变量的设置。 安装 Git同样在 Git 官网的下载页面，可以下载 Linux、Windows、mac OS 三个版本的安装包，点击 windows 下载，安装在本地磁盘中。安装完成，点击鼠标右键，若出现 Git GUI Here 和 Git Bash Here，则下载安装成功。后续操作全部在 Git Bash 下执行。 安装 Hexo 首先在任意磁盘新建文件夹 MyBlog，用来统一管理博客。然后在该文件夹下打开 Git Bash，使用命令安装 Hexo，并检查是否安装成功。12npm i -g hexo # 安装 hexohexo -v # 检查 hexo 的版本 启动 Hexo 本地服务，可以得知服务运行在 http://localhost:4000 上，我们可以通过该网址在本地访问博客。1hexo s 创建一篇博客，文章保存在 /MyBlog/source/_posts，博客内容使用 Markdown 语法编写，这里推荐一款专门编写 Hexo 博客的编辑器 HexoEditor，源项目 可以在 Github 上查看，也可以 直接下载 发布版本。1hexo n &quot;文章名称&quot; 博客编辑完成后，退回至 /MyBlog 文件夹下，使用命令 清空 缓存文件和已经生成的静态文件，然后生成静态文件，从本地进行访问。12hexo clean # 清空缓存hexo g # 生成静态文件 在 Github 中创建个人仓库 首先在 Github 上创建一个新仓库，以如下格式命名：12&quot;GitHub_ID&quot;.github.io # 命名格式ID-Wanwan.github.io # 我的github id是 ID-Wanwan， 现在需要将本地博客与 Github 建立关联。在根目录 /MyBlog 下打开 Git Bash，安装插件 hexo-deployer-git。1npm install hexo-deployer-git --save 根目录中有博客配置文件 _config.yml，用文本编辑器打开配置文件，在 # Deployment 下的 deploy 属性中添加如下内容：1234deploy: type: git repo: https://github.com/ID-Wanwan/ID-Wanwan.github.io.git branch: master 其中 repo 是步骤1中 新建仓库的地址 ，后面再加上 .git 即可。到此本地博客就与 Github 建立了关联，可以进行下一步部署。 将 Hexo 部署在 Github 上 输入部署命令： 1hexo d 发现出现 Erroe: Spawn failed，根据提示，发现需要设置 Github 的邮箱和用户名信息，来帮助辨认身份并登录到远端的个人仓库。 12git config --global user.email &quot;you@example.com&quot; # 设置 Github 邮箱git config --global user.name &quot;Your Name&quot; # 设置 Github 用户名 重新设置完成后，再次输入部署命令 hexo d，然后输入账号密码登录 Github 。 若运行过程中发现如下错误： 1error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 根据查阅资料得知，这是安全设置的问题，解决方式如下： 首先执行： git config http.sslVerify &quot;false&quot; 若发现如下错误：fatal：not in a git directory 执行：git config --globle http.sslVerify &quot;false&quot; 经过如上步骤，再次部署博客 hexo d，Github 仓库中就有刚才发布的博客了。 在浏览器中输入 Github 博客仓库的名称，即可远端访问博客，部署完成。 1https://ID-Wanwan.github.io 发布文章 通过 hexo n &quot;文章名称&quot;，创建一篇新的博客，用文本编辑器编辑文章。 在本地预览博客发布后的样式。123hexo clean # 清空缓存 hexo g # 生成静态文件hexo s # 启动本地服务 确认无误后，将博客发布到 Github 平台。1hexo d 更换 Hexo 主题 在 Github 或者 Hexo 官网上寻找自己喜欢的博客主题，这里以在 Github 中下载 yilia 主题为例。在本地博客根目录 /MyBlog 下打开 Git Bash，可以以如下格式下载主题：12git clone 主题链接.git themes/主题文件夹 # 参考格式git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 在 /MyBlog/themes 中可以看到刚才下载好的主题， 退回到根目录 /MyBlog，打开配置文件 _config.yml，在 # Extensions 下更改 theme 的值为主题文件夹的名称。1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 更新设置，在本地预览。123hexo clean # 清空缓存 hexo g # 生成静态文件hexo s # 启动本地服务 确认无误后，部署至 Github 平台，主题更换完成。1hexo d 后记到这里个人博客就已经初步搭建成功，后续可以根据自己的需要更改主题的美化设置，深入探索 Hexo 框架或者其他博客框架的其他内容。 书签HexoEditor 快捷键","categories":[],"tags":[]},{"title":"MySQL","slug":"MySQL","date":"2019-11-04T14:27:07.000Z","updated":"2019-11-04T17:29:22.968Z","comments":true,"path":"2019/11/04/MySQL/","link":"","permalink":"http://yoursite.com/2019/11/04/MySQL/","excerpt":"1. SQL 分类 DDL（Data Definition Language），数据定义语言： 定义数据库对象：数据库、表、列表等。 create、drop、alter等。 DML（Data Manipulation Language），数据操作语言： 对数据库中表的数据进行增删改。insert、delete、update等。 DQL（Data Query Language），数据查询语言： 查询数据库中表的记录（数据)。select、where等。 DCL（Data Control Language），数据控制语言： 定义数据库的访问权限和安全级别，及创建用户。GRANT、REVOKE等。","text":"1. SQL 分类 DDL（Data Definition Language），数据定义语言： 定义数据库对象：数据库、表、列表等。 create、drop、alter等。 DML（Data Manipulation Language），数据操作语言： 对数据库中表的数据进行增删改。insert、delete、update等。 DQL（Data Query Language），数据查询语言： 查询数据库中表的记录（数据)。select、where等。 DCL（Data Control Language），数据控制语言： 定义数据库的访问权限和安全级别，及创建用户。GRANT、REVOKE等。 1.1 DDL：数据定义1.1.1 操作数据库（CRUD） C(Create)：创建 create database 数据库名;：创建数据库（默认字符集 var)。 create database if not exists 数据库名;：创建数据库前，先检测是否从重名，重名不报错会出警告；不重名则创建。 create database 数据库名 character set 字符集名;：创建数据库并指定字符集。 R (Retrieve)：查询 SHOW DATABASES;：查询所有数据库的名称。 show create database 数据库名;：查询某个数据库的字符集（创建语句）。 U (Update)：修改 alter database 数据库名 character set 字符集名;：修改数据库的字符集。 D (Delete)：删除 drop database 数据库名;：删除数据库。 drop database if exists 数据库名;：删除数据库前先判断是否存在，存在才删除。 使用数据库 use 数据库名;：使用数据库。 select database();：查询当前正在使用的数据库。 1.1.2 操作表（CRUD） C(Create)：创建 create table 表名 ( 列名1 数据类型1， # 数据库类型：整数类型、小数类型、日期类型、字符串、 列名2 数据类型2， # 二进制、BLOB、CLOB ... 列名n 数据类型n ); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 ![1570087978757](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570087978757.png) ![1570088223160](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570088223160.png) - `create table 表名1 like 表名2;`：复制表2。![1570088462528](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570088462528.png) 2. R (`Retrieve`)：查询 - `show tables;`：查询某个数据库中所有表的名称。![1570087773216](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570087773216.png) - `desc 表名;`：查询表结构。![1570087781197](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570087781197.png) - `show create table 表名;`：查询表的创建语句。![1570089183036](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089183036.png) 3. U (`Update`)：修改 - `alter table 表名 rename to 新表名;`：修改表名。![1570089011667](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089011667.png) - `alter table 表名 character set 字符集名;`：修改表的字符集。![1570089253870](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089253870.png)![1570089268029](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089268029.png) - `alter table 表名 add 列名 数据类型;`：添加一列。![1570089672862](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089672862.png)![1570089704936](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089704936.png) - `alter table 表名 change 新列名 新数据类型`：修改列名称、类型。![1570089864614](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570089864614.png) - `alter table 表名 modify 原列名 新数据类型;`：只修改列名的数据类型。![1570090045012](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570090045012.png) - `alter table 表名 drop 列名`：删除列。![1570090161501](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570090161501.png)4. D (`Delete`)：删除 - `drop table 表名;`：删除表。 - `drop table if exists 表名;`：删除表前先判断是否存在，存在才删除。------## 1.2 **DML**：增改删表中数据### 1.2.1 添加数据- `insert into 表名(列名1, 列名2, ...., 列名n) values(值1, 值2, ..., 值n);`![1570093386552](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570093386552.png)![1570093366484](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570093366484.png)- 注意事项: - 列名与值，需一一对应； - 表名后不添加列名，默认指给所有列添加列名；------### 1.2.2 删除数据- `delete from 表名 [where 条件]`：按条件从表中删除数据。![1570110108818](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110108818.png)![1570110141047](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110141047.png)![1570110160574](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110160574.png)- `delete from 表名;` ：删除表中所有记录，有多少条记录就执行多少次，效率低不推荐。- `TRUNCATE table 表名;`：删除表，然后在创建一个一模一样的空表，推荐使用该方法。------### 1.2.3 修改数据- `update 表名 set 列名1=值1, 列名2=值2, ... [where 条件];`：修改表中记录。![1570110763329](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570110763329.png)- `update 表名 set 列名1=值1, 列名2=值2, ...;`：不加条件，修改所有记录。------## 1.3 DQL：查询表中的记录​ `select * from 表名;`：单表查询### 1.3.1 语法```mysqlselect 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定; 1.3.2 基础查询 多字段查询 在 select 后的字段列表中写明想查询的字段即可。如查询姓名与年龄： 1select name, age from student; 去除重复 distinct 关键字可以对查询结果集去重。如查询城市： 1select distinct address from student; -- 查询城市 计算列 将可计算列的字段，在查询字段列表中用算术符号连接即可。如查询数学和英语成绩之和： 1select name,math,english, math + english from student; 注意：如果有 null 参与运算，结果都为 null，MySQL有 IFNULL() 函数来解决该问题。 1select name, math, english, math + IFNULL(english, 0) from student; 即在 english 字段中，如果遇到 null ，就将其替换为 0 参与计算，及如果如下： 起别名 在字段列表中，某个字段后添加 AS 和新名字即可。如将 math + IFNULL(english, 0) 改为 总分 ： 1select name, math, english, math + IFNULL(english, 0) as 总分 from student; 或者 不使用as关键字，直接空格后添加新名字 也能实现改名功能： 1select name, math, english, math + IFNULL(english, 0) 总分 from student; 1.3.3 条件查询 where 子句后跟条件 运算符 比较运算符：&gt;、&lt;、&gt;=、&lt;=、=、&lt;&gt;（不等于）； BETWEEN...AND：在某个*闭区间 *范围内的记录； 12-- 查询年龄在20到50岁之间的人select * from student where age between 20 and 50; IN(集合)：表示多个值，用逗号分隔； 12-- 查询年龄20岁，22岁，55岁的人select * from student where age in (20,22,55); LINK &#39;&#39;：模糊查询； 12-- 查询姓马的人，% 表示之后的任意字符select * FROM student WHERE name LIKE &apos;马%&apos;; 12345-- 查询姓马且名字字数为一个字的人， _ 下划线表示一个占位字符SELECT * FROM student WHERE name LIKE &apos;马_&apos;;-- 查询姓马且名字字数为两个字的人， _ 下划线表示一个占位字符SELECT * FROM student WHERE name LIKE &apos;马__&apos;; ![1570371035533](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570371035533.png)![1570371063776](C:\\Users\\25177\\AppData\\Roaming\\Typora\\typora-user-images\\1570371063776.png) IS NULL：查询某列为 null 的值，不能写=NULL ； 12345-- 查询英语成绩为null的人，不能用运算符进行判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为null的人SELECT * from student WHERE english IS NOT NULL; ) 1.3.4 排序查询 语法：order by 子句 1SELECT * FROM 表名 WHERE 条件子句 ORDER BY 排序字段1 排序方式1, 排序字段2 排序方式2 ... 排序方式： ASC：升序排序，默认方式； DESC：降序排序； 123-- 按照数学成绩升序/降序排序SELECT * FROM student ORDER BY math;SELECT * FROM student ORDER BY math DESC; ) 多字段排序：若某一字段数据相同，则可以按照第二排序字段进行排序。 123-- 按照数学成绩、英语成绩进行升序排序SELECT * FROM student ORDER BY math, english;SELECT * FROM student ORDER BY math ASC, english ASC; 1.3.5 聚合函数​ 聚合函数：将一列数据作为整体，进行纵向计算。 count：计算个数，一般选择非空的列（主键）。 12345678SELECT COUNT(列名) FROM 表名; -- 该函数排除null值-- 计算人数SELECT COUNT(name) FROM student;-- 计算参加英语考试的人数SELECT COUNT(english) FROM student;SELECT COUNT(IFNULL(english, 0)) FROM student; -- 改进如下，将null值算进去 )) max：计算最大值； 12-- 计算数学成绩的最大值SELECT MAX(math) FROM student; min：计算最小值； 12-- 计算数学成绩的最小值SELECT MIN(math) FROM student; sum：计算总和； 12-- 计算数学成绩的总和SELECT SUM(math) FROM student; avg：计算平均值； 12-- 计算英语成绩的平均成绩SELECT AVG(english) FROM student; 1.3.6 分组查询 语法： 1SELECT 分组字段、聚合函数 FROM 表名 GROUP BY 分组字段; 12345-- 按照性别分组，分别查询男、女同学的数学平均分SELECT sex, SUM(math) FROM student GROUP BY sex;-- 按照性别分组，分别查询男、女同学的人数SELECT sex, COUNT(sex) FROM student GROUP BY sex; ) 12-- 按照性别分组，分别查询数学成绩大于70分的男、女同学的人数和平均分SELECT sex, COUNT(sex), AVG(math) FROM student WHERE math &gt; 70 GROUP BY sex; 12-- 按照性别分组，分别查询数学成绩大于70分的男、女同学的人数和平均分，低于70分的不参与分组，分组之后人数大于2人，使用 having 子句进行分组条件限制SELECT sex, COUNT(sex), AVG(math) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(sex) &gt; 2; 注意： 分组之后查询的字段：分组字段、聚合函数； WHERE 和 HAVING 的区别？ WHERE 在分组前进行限定，如果不满足条件，则不参与分组；HAVING 在分组之后进行限定，如果结果不满足条件，则不会被查询到。 WHERE 后不可以跟聚合函数；HAVING 后可以跟聚合函数。 1.3.7 分页查询 语法： 1LIMIT 开始的索引, 每页查询的条数; -- 公式：开始的索引 = (当前页码-1) * 每页条数; 1234-- 每页显示3条记录，分别查询第一页、第二页、第三页SELECT * FROM student LIMIT 0, 3;SELECT * FROM student LIMIT 3, 3;SELECT * FROM student LIMIT 6, 3; )) 不同的数据库实现分页的操作不一样，MySQL中分页操作是 LIMIT 。 1.3.8 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性、完整性。 分类： 主键约束：PRIMARY KEY，该列的值 非空且唯一，一张表 有且只有一个主键，是表中记录的唯一标识。 自动增长：如果某一列的数据类型是 数值型，可以使用 auto_increment 关键字使该值根据上一条数据自动增长，一般与主键一起用。 非空约束：NOT NULL，该列的值不能为空。 唯一约束：UNIQUE，该列的值不能重复。 外键约束：FOREIGN KEY。 添加方式： 在创建表时添加约束： 1234CREATE TABLE stu ( id INT, name VARCHAR(20) 约束名称 -- 约束); 创建完表后添加约束： 1ALTER TABLE student MODIFY name varchar(20) 约束名称; 特殊约束——外键约束：foreign key ，让表与表产生关系，从而保证数据的正确性。 123456789101112131415-- 现添加表如下：create table emp ( id int primary key auto_increment, name varchar(30), age int, dep_name varchar(30), dep_location varchar(30));INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;张三&apos;,20,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;李四&apos;,21,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;王五&apos;,20,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;老王&apos;,20,&apos;销售部&apos;,&apos;深圳&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;大王&apos;,22,&apos;销售部&apos;,&apos;深圳&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;小王&apos;,18,&apos;销售部&apos;,&apos;深圳&apos;); 发现 ‘研发部’,’广州’ 和 ‘销售部’,’深圳’ 有数据冗余，重复多次。 1234567891011121314151617181920212223242526-- 解决方法，将表拆分成两张表：部门表和员工表-- 部门表，主表create table department ( id int PRIMARY KEY auto_increment, dep_name varchar(20), dep_location varchar(20));-- 员工表，从表create table employee ( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 外键对应主表的主键 constraint dep foreign key (dep_id) references department(id));-- 添加两个部门INSERT INTO department VALUES (null,&apos;研发部&apos;,&apos;广州&apos;), (null,&apos;销售部&apos;,&apos;深圳&apos;);-- 添加员工INSERT INTO employee (name, age, dep_id) VALUES (&apos;张三&apos;, 20, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;李四&apos;, 21, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;王五&apos;, 20, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;老王&apos;, 22, 2);INSERT INTO employee (name, age, dep_id) VALUES (&apos;大王&apos;, 20, 2);INSERT INTO employee (name, age, dep_id) VALUES (&apos;小王&apos;, 18, 2); ) 添加外键方式： 在创建表时，可以添加外键。 12345create table 表名 ( ... 外键列, constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)); 删除外键。 1alter table 从表名 drop foreign key 外键名称; 创建表之后，添加外键。 1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称); 级联操作 级联更新 on update cascade：在添加外键时设置，在更改主表主键时，从表的外键会实时更新。 1... on update cascade; 1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称) on update cascade; 级联删除 on delete cascade：在添加外键时设置，在删除主表主键时，从表的外键关联的记录会实时删除。 1... on delete cascade; 1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称) on delete cascade; 2. 数据库设计2.1 多表之间的关系2.1.1 分类 一对一： 人和身份证，一个人只能由一个身份证，一个身份证只对应一个人。 一对多（多对一): 如部门和员工，一个部门有多个员工，而一个员工隶属于一个部门。 多对多： 学生和课程，一个学生可以选择很多课程，一门课程可以被多个学生选择。 2.1.2 实现关系 一对多（多对一）： 部门和员工：一个部门有多个员工，所以 部门(1) —&gt; 员工(n)。 实现方式：在多的一方建立外键，指向一的一方的主键。 多对多： 学生与课程，一个学生可以选多个课程，一门课程可以被多个学生选择，所以 学生(m) —-&gt; 课程(n)。 实现方式：需要第三张中间表，至少包含两个字段作为第三张表的外键，分别指向两张表的主键。 2.1.3 案例​ 某旅游网站，有旅游线路分类、旅游线路、用户信息等功能，建立表存储这些信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-- 创建旅游线路分类表CREATE TABLE tab_category ( cid INT PRIMARY KEY auto_increment, cname VARCHAR (100) NOT NULL UNIQUE);-- 添加旅游线路分类数据INSERT INTO tab_category (cname) VALUES(&apos;周边游&apos;),(&apos;出境游&apos;),(&apos;国内游&apos;),(&apos;港澳游&apos;);-- 创建旅游线路表CREATE TABLE tab_route ( rid INT PRIMARY KEY auto_increment, rname VARCHAR (100) NOT NULL UNIQUE, price DOUBLE, rdate date, cid INT, FOREIGN KEY (cid) REFERENCES tab_category (cid));-- 创建用户表-- uid 用户主键-- username 用户名-- password 密码-- name 真实姓名-- birthday 生日-- sex 性别-- telephone 电话-- email 邮箱CREATE TABLE tab_user ( uid INT PRIMARY KEY auto_increment, username VARCHAR (100) NOT NULL UNIQUE, PASSWORD VARCHAR (30) NOT NULL, NAME VARCHAR (100), birthday date, sex CHAR (1) DEFAULT &apos;男&apos;, telephone VARCHAR (11), email VARCHAR (100));-- 创建收藏表，中间表 关联路线表和用户表CREATE TABLE tab_favorite ( rid INT, date datetime, uid INT, PRIMARY KEY (rid, uid), FOREIGN KEY (rid) REFERENCES tab_route (rid), FOREIGN KEY (uid) REFERENCES tab_user (uid)); 数据库关系如下： 旅游路线分类(1) —&gt; 旅游线路(n) 用户收藏线路(m) —&gt; 旅游线路(n) 2.2 范式概念：设计数据库时，需要遵循的一些规范。 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 其中，第一范式(1NF) ，第二范式(2NF)，第三范式(3NF) 是数据库学习的重点。 2.2.1 第一范式（1NF）​ 每一列都是不可分割的原子数据项。数据库建出来的表都是符合 1NF 的，以下表为例： 第一范式存在问题： 存在严重的 数据冗余 ：姓名、系名、系主任、课程名称； 数据添加 存在问题：添加新开设的系和系主任时，添加的数据不合法； 数据删除 存在问题：删除记录时会将系和系主任数据一起删除； 2.2.2 第二范式（2NF）​ 在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）。 函数依赖：A —&gt; B，如果通过 A 属性的值，可以唯一确定 B 属性的值，则 B 依赖于 A。 例如：学号 —&gt; 姓名，系名 —&gt; 系主任。 完全函数依赖：A —&gt; B，如果 A 是 属性组 ，则 B 属性值的确定需要依赖于 A 属性组中 所有属性的值。 例如：(学号，课程名称) —&gt; 成绩，单学号/课程名称 无法确定成绩。 部分函数依赖：A —&gt; B，如果 A 是 属性组，则 B 属性值的确定仅依赖于 A 属性组中 某些属性值。 例如： (学号，课程名称) —&gt; 姓名，由学号即可确定姓名，不需要课程名称。 传递函数依赖：A —&gt; B，B —&gt; C，如果通过 A 属性的值，可以唯一确定 B 属性的值，通过 B 属性的值，可以唯一确定 C 属性的值，则称 C 传递函数依赖于 A。 例如：学号 —&gt; 姓名，姓名 —&gt; 系名，则 系名 传递依赖于 学号。 ​ 第二范式在 1NF 的基础上，需要对表进行拆分消除部分函数依赖，解决 1NF 存在的问题： 发现第二范式消除部分函数依赖后，仍存在问题： 数据添加 存在问题：添加新开设的系和系主任时，添加的数据不合法； 数据删除 存在问题：删除记录时会将系和系主任数据一起删除； 即，存在函数传递依赖。 2.2.3 第三范式（3NF）​ 在 2NF 的基础上，任何非主属性不依赖于其他非主属性（在 2NF 的基础上消除传递依赖）。 解决方法：在 2NF 基础上再分一张表如下。 上述问题全部解决。 2.3 数据库的备份和还原 命令行 1mysqldump -u用户名 -p密码 数据库名 &gt; 保存路径 -- 备份 还原： 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行sql文件 图形化工具 2.4 多表查询 查询语法： 123456select 列名列表from 表名列表where 条件 例子，准备sql: 1234567891011121314151617181920212223-- 创建部门表CREATE TABLE dept ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));INSERT INTO dept (NAME) VALUES(&apos;开发部&apos;), (&apos;市场部&apos;), (&apos;财务部&apos;);-- 创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1); 直接查询两张表，结果是两张表的 笛卡尔积： 1select * from emp, dept; 2.4.1 内连接查询 隐式内连接：使用 WHERE 条件消除无用数据。 1234-- 查询每个员工的信息及其就职部门SELECT emp.id, emp.name, gender, salary, join_date, dept.nameFROM emp, deptWHERE emp.dept_id = dept.id; 也可以给表取别名，替换复杂的表名来简化查询语句： 1234-- 查询每个员工的信息及其就职部门SELECT t1.id, t1.name, gender, salary, join_date, t2.nameFROM emp t1, dept t2WHERE t1.dept_id = t2.id; 显式内连接：使用 inner join … on 来连接两张表 1select 字段列表 from 表名1 inner join 表名2 on 条件; -- inner 可省略 1234-- 查询每个员工的信息及其就职部门，同样也可以给表名取别名SELECT emp.id, emp.name, gender, salary, join_date, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id; 内连接注意事项： 从哪些表中查询数据； 查询条件是什么； 查询哪些字段； 2.4.2 外连接查询 左外连接：使用 left outer join … on 关键字，查询的是 左表全部数据 和 与右表的交集部分，可以避免连接表时某些记录由于外键不存在，而查询不到。 1select 字段列表 from 表1 left outer join 表2 on 条件; -- outer可省略 上述例子添加一名新员工如下，他没有分配部门。 若直接连接两张表查询所有员工的信息和部门，则该员工会因为 未分配部门 而查询不到，此时需要外连接。 1234-- 查询所有员工的信息和部门，若未分配部门，则该员工部门信息显示 nullSELECT t1.*, t2.nameFROM emp t1 LEFT OUTER JOIN dept t2 -- dept 左外连接 empON t1.dept_id = t2.id; 此时所有员工信息就可正确查询。 右外连接：道理同左外连接，只是查询的是 查询的是 右表全部数据 和 与左表的交集部分。 1select 字段列表 from 表1 right outer join 表2 on 条件; -- outer可省略 1234-- 查询所有员工的信息和部门，若未分配部门，则该员工部门信息显示 nullSELECT t1.*, t2.nameFROM dept t2 RIGHT OUTER JOIN emp t1 -- dept 右外连接 empON t1.dept_id = t2.id; 2.4.3 子查询 概念：查询中 嵌套查询，则嵌套的查询被称为子查询。 语法： 1234567select 字段列表from 表名where 条件1, ( -- ()内是子查询 select 字段列表 from 表名 where 条件) 条件2; 子查询的不同情况 结果是 单行单列 的：子查询可以作为条件，使用运算符（=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;）去判断。如： 12345678910-- 查询工资最高的员工信息-- 1. 查询工资最高是多少-- 2. 查询谁的工资是最高工资SELECT t1.*, t2.nameFROM emp t1, dept t2WHERE t1.dept_id = t2.id AND -- 连表t1.salary = ( -- 查询哪个人的工资等于最大工资 SELECT MAX(salary) -- 查询最大工资 FROM emp t1); 结果是 多行单列 的：子查询可以作为条件，使用运算符 IN 去判断。 123456789-- 查询财务部、市场部所有员工的信息-- 查询财务部、市场部所属的部门编号-- 查询员工信息中，符合这些编号的员工SELECT * FROM empWHERE dept_id IN ( SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 结果是 多行多列 的：子查询可以作为一张 虚拟表。 12345678910111213141516-- 查询入职日期是2011-11-11日之后的员工信息和部门信息-- 查询符合入职日期条件的员工，将其单独存入一张虚拟表-- 将虚拟表与部门信息表连接SELECT t2.*, t1.name FROM dept t1, ( SELECT * FROM emp WHERE join_date &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id;-- 普通内连接也可以实现SELECT t1.*, t2.name FROM emp t1, dept t2WHERE t1.dept_id = t2.id AND t1.join_date &gt; &apos;2011-11-11&apos;; 2.4.4 多表查询练习​ 现有部门表，职位表，员工表，工资表如下： ))) 需求： 查询所有员工信息。查询员工编号、姓名、工资、职务名称、职务描述。 1234-- 查询所有员工信息。查询员工编号、姓名、工资、职务名称、职务描述。SELECT t1.id, ename, salary, jname, descriptionFROM emp t1, job t2WHERE t1.job_id = t2.id; 查询员工编号、姓名、工资、职务名称、职务描述、部门名称、部门位置。 1234-- 查询员工编号、姓名、工资、职务名称、职务描述、部门名称、部门位置。select t1.id, ename, salary, jname, description, dname, locfrom emp t1, job t2, dept t3where t1.job_id = t2.id and t1.dept_id = t3.id; 查询员工姓名、工资、工资等级。 123456789-- 查询员工姓名、工资、工资等级。select t1.ename, t1.salary, t2.gradefrom emp t1, salarygrade t2,WHERE t1.salary BETWEEN t2.losalary AND t2.hisalary; 查询员工姓名、工资、职务名称、职务描述、部门名称、部门位置、工资等级。 1234567891011121314-- 查询员工姓名、工资、职务名称、职务描述、部门名称、部门位置、工资等级。SELECT t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.loc, t4.gradeFROM emp t1, job t2, dept t3, salarygrade t4WHERE t1.job_id = t2.id AND t1.dept_id = t3.id AND t1.salary BETWEEN t4.losalary AND t4.hisalary; 查询部门编号、部门名称、部门位置、部门人数。 123456789101112-- 查询部门编号、部门名称、部门位置、部门人数。SELECT t2.id 部门编号, t2.dname 部门名称, t2.loc 部门位置, COUNT(t1.dept_id) -- 按部门编号统计个数FROM emp t1, dept t2WHERE t1.dept_id = t2.idGROUP BY t1.dept_id; -- 按部门编号分组 查询所有员工的姓名及其直接上级的姓名，没有领导的员工也要查询。 123456789101112-- 查询所有员工的姓名及其直接上级的姓名，没有领导的员工也要查询。SELECT t1.id, t1.ename, t2.id, t2.enameFROM emp t1LEFT JOIN -- 使用左连接，左表是全部员工，右表是直接上级 emp t2ON t1.mgr = t2.id; 3. 事务3.1 事务的基本介绍 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么 同时成功，要么 同时失败。 操作： 开启事务 start transaction： 回滚 rollback： 提交 commit： 现有表如下： 123456789101112131415-- 开启事务START TRANSACTION;-- 转账操作-- 张三账户-500UPDATE account SET balance = balance - 500 WHERE NAME = &apos;张三&apos;;出错了...-- 李四账户+500UPDATE account SET balance = balance + 500 WHERE NAME = &apos;李四&apos;;-- 发现没有问题，提交事务COMMIT;-- 发现出问题，回滚事务，返回到事务开启的时候ROLLBACK; MySql 数据库中事务默认自动提交，一条 DML （增删改）语句会自动提交一次事务。 查看事务的默认提交方式： 1SELECT @@autocommit; -- 1代表自动提交，0代表手动提交 修改事务的默认提交方式： 1SET @@autocommit = 1/0; 3.2 事务的四大特征 原子性：是不可分割的最小操作单位，同时成功 / 同时失败。 持久性：当事务提交 / 回滚后，数据库会发生持久化的保存。 隔离性：多个事务之间，相互独立。 一致性：事务操作前后，数据总量不变。 3.3 事务的隔离级别 (了解) 概念：多个事务之间是隔离的，相互独立。如果多个事务操作同一批数据，会引发一些问题，设置不同的隔离级别可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据。 不可重复读（虚读）：同一个事务中，两次读取到的数据不一致。 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： read uncommitted： 读未提交，会产生上述三种问题。 read committed：（Oracle 默认） 读已提交，解决 脏读 问题。 repeatable read：（MySQL 默认） 可重复度，解决 脏读、不可重复读 问题。 serializable： 串行化，解决 所有问题。 注意：隔离级别从小到大安全性回来越高，效率却越来越低。 数据库隔离级别相关的sql语句： 查询： 12SELECT @@transaction_isolation; -- 查询数据库隔离级别（MySQL8.0以后版本）SELECT @@tx_isolation; -- MySQL 8.0 以前版本 设置： 1set global transaction isolation level 级别字符串; -- 设置数据库隔离级别 脏读案例： 1234-- 数据库隔离级别为 read uncommitted-- 开启两个事务，第一个事务对数据进行修改但不提交，第二个事务可以读取到第一个事务修改后的数据。update account set balance = 500 where id = 1;update account set balance = 1500 where id = 2;","categories":[],"tags":[]}]}