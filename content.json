{"meta":{"title":"Wanwan","subtitle":"","description":"","author":"Wanwan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-11-12T06:06:02.000Z","updated":"2019-11-12T06:06:46.498Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-12T06:05:10.000Z","updated":"2019-11-12T06:06:20.075Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机网络总结 —— 传输层","slug":"计算机网络总结-——-传输层","date":"2019-11-17T07:28:38.000Z","updated":"2019-11-19T07:41:37.928Z","comments":true,"path":"2019/11/17/计算机网络总结-——-传输层/","link":"","permalink":"http://yoursite.com/2019/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93-%E2%80%94%E2%80%94-%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"前言&nbsp;&nbsp;&nbsp;&nbsp; 网络层篇中介绍了的IP协议和ICMP协议，深度剖析数据报在网络中传输的方式，路由设备如何选择传输结点等内容。其中需要重点学习IP协议中 IP路由，IP分片 两大知识点。接下来着重总结OSI协议体系中最关键的内容 传输层，以及TCP/IP体系中的另一大支柱 TCP/UDP协议。","text":"前言&nbsp;&nbsp;&nbsp;&nbsp; 网络层篇中介绍了的IP协议和ICMP协议，深度剖析数据报在网络中传输的方式，路由设备如何选择传输结点等内容。其中需要重点学习IP协议中 IP路由，IP分片 两大知识点。接下来着重总结OSI协议体系中最关键的内容 传输层，以及TCP/IP体系中的另一大支柱 TCP/UDP协议。 传输层&nbsp;&nbsp;&nbsp;&nbsp; 传输层的作用是实现端到端（进程到进程）的连接，网络层识别IP地址，能够将信息送到正确的主机，而主机应该使用什么协议接收信息，就是由传输层来完成。它是OSI中最关键的一层，负责总体数据传输和数据控制，为会话层高三层提供可靠的传输服务，对网络层提供可靠的目的地址信息。 &nbsp;&nbsp;&nbsp;&nbsp; 传输层的作用如下： 多路复用和分用：即传输层能够区分不同进程的数据并加以区分处理。 复用：当传输层从应用程序接收报文后，要封装在传输层的段中再交给网络层发送。 分用：当传输层从网络层接收数据后，必须将数据正确递交给某个应用程序。 可靠数据传输：TCP协议，提供了面向连接的、可靠的、具有用测控制的数据传输服务，弥补网络层的不足。 流量控制及拥塞控制 流量控制：防止接收端速度太慢造成溢出和丢包，只需要管理端与端之间的流量传输，属于局部控制。 拥塞控制：监控网络中是否发生拥塞，并做出相应该改变，需要所有路由器和主机一起完成，属于全局控制。 寻址：需要定位应用程序在哪里。 传输层实现的服务分为两种形式：面向连接的数据传输服务 TCP协议 和 无连接的数据传输服务 UDP协议。 UDP 协议&nbsp;&nbsp;&nbsp;&nbsp; UDP协议是传输层的协议，功能在IP数据报服务的基础上增加了最基本的服务：复用和分用、差错检测。 &nbsp;&nbsp;&nbsp;&nbsp; UDP协议的特点如下： UDP无连接。时间上，不存在建立连接所需要的时延；空间上，在端系统中不需要维护链接状态，无开销。 分组首部开销小。TCP首部 20 字节，UDP首部 8 字节。 UDP没有拥塞控制。网络中的拥塞不会影响主机发送速率，适用于某些可以容忍部分数据丢失，但不能由较大时延的实时应用。 UDP提供不可靠的服务。UDP不保证可靠交付，但是能尽最大努力交付数据，其维护传输可靠性的工作交给 应用层 完成。 UDP面向报文传输。应用层交付的报文，添加UDP首部后直接向下交付给网络层，不合并也不拆分，保留报文边界。网络层交付的报文，去除首部直接向上交付给应用层，报文不分割。 UDP用于一次性传输比较少量数据的网络应用。如DNS、SNMP等，数据可靠传输并非最重要的，是否有较大时延才是最重要的。 UDP支持一对一，一对多，多对多，多对一通信。 UDP 的首部格式&nbsp;&nbsp;&nbsp;&nbsp; UDP数据报分为 首部 和 用户数据部分，整个UDP数据报封装在IP数据报的数据部分。UDP首部有 8 字节，4 个 2字节 字段构成，其报文结构如下： 字段 描述 源端口号 发送端口，需要对方回信时使用，不需要时全 置0 目的端口号 接收端口，在传输终点交付报文时需要用到 UDP长度 UDP数据报的长度（首部+数据），最小值为 8（只有首部） 校验和 检测UDP数据报在传输中是否有错，有错则丢弃。可选项，不需要置0 UDP校验和计算：UDP的校验和计算，要计算 伪首部 + UDP首部 + UDP数据部分，伪首部占 12 字节。其中UDP长度计算两次，如果检验和有错，UDP数据报被丢弃，不产生任何差错报文。 UDP 的应用&nbsp;&nbsp;&nbsp;&nbsp; UDP协议因其特殊性 ———— 高速传输数据，在实际工作中被广泛应用，在某些方面有着TCP协议不可比拟的优势。也因为UDP协议的特殊性，使得传输层在处理数据传输时有更多的选择。对可靠性要求高选择TCP协议，对传输率要求高选择UDP协议，二者相辅相成使传输层功能更完善。以下是UDP使用的常见端口： 端口 协议 说明 69 TFTP 简单文件传输协议 53 DNS 域名服务 123 NTP 网络时间协议 111 RPC 远程过程调用 161 SNMP 简单邮件传输协议 综上，UDP使用在 视频传输、实时通信 等对实时性要求高，需要告诉传输的领域。UDP不关心发送的数据是否到达目标主机，数据是否出错，它的可靠性全由上层协议来保障。如：QQ语音，QQ视频，直播视频…. TCP 协议&nbsp;&nbsp;&nbsp;&nbsp; TCP协议是为了在主机间实现高可靠性数据交换的传输协议，它面向连接，数据传输之前必须建立连接，数据传输完成后要释放连接，支持多种网络应用程序。主要解决 可靠、有序、无丢失、不重复 的传输问题，其特点如下： TCP面向连接。在通信前需要建立连接，通信结束需要释放连接。 TCP保证可靠性。TCP提供可靠的交付服务，即TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。 TCP面向字节流传输。TCP的传输单位是 字节，虽然在传输过程中数仍然被划分成数据报，但只是为了方便在网络层的传输，接收端最终收到的数据与发送端一致。 TCP提供全双工通信。TCP的两端既可作为发送端，也可作为接收端。 TCP只支持一对一传输。TCP只能提供端到端的通信，一条TCP连接的两端只能有两个端点。 TCP 的首部格式&nbsp;&nbsp;&nbsp;&nbsp; TCP报文分为数据首部和TCP数据两部分，其首部格式如下: table th:last-of-type { width: 500px; } 字段 长度 / bit 描述 源端口 16 辨识发送连接端口 目的端口 16 辨识接收连接端口 序列号 Seq 32 当前TCP数据报数据部分的第一个字节的序号 确认号 Ack 32 期望收到的数据开始序列号，即已经收到的数据字节长度+1。如果含有同步化旗标 SYN，则本序列号+1是第一个数据比特的序列码。如果没有同步化旗标 SYN，则此为第一个数据比特的序列码 报头长度 4 TCP数据报首部的长度 保留字段 置0 URG 1 URG=1，表示本数据报的数据部分包含紧急信息，此时紧急指针有效 ACK 1 ACK=1，确认号字段有效。TCP连接建立后所有报文ACK字段都需置1 PSH 1 PSH=1，接收方会立即将数据交付给应用程序，不需要等缓冲区满再提交 RST 1 RST=1，表示TCP连接出现严重问题，必须要释放重新连接 SYN 1 SYN在建立连接时使用。SYN=1，ACK=0，当前报文端是连接请求报文。SYN=1，ACK=1，当前报文端是一个同意建立连接的应答报文 FIN 1 FIN=1，表示此报文段是一个释放连接的请求报文 窗口 16 接收窗口大小，实现TCP流量控制。表示当前接收端接收窗口的剩余容量。发送端将发送窗口调整成该值大小 检验和 16 用于接收端检验整个数据报在传输过程中是否出错 紧急指针 16 用于标识紧急数据的尾部 选项 \\ 当首部长度 &gt; 20 字节时才有效，最多 40 字节 TCP 可靠传输机制&nbsp;&nbsp;&nbsp;&nbsp; 可靠的传输应该满足两个要求： 传输的信道不产生差错。 ———— 能够正确地传输数据 保证传输数据的正确性，无差错、不丢失、不重复、按序到达。 ———— 接收端能及时处理发送端的数据 &nbsp;&nbsp;&nbsp;&nbsp; TCP为了提供可靠传输，使用了以下机制实现： 采用 三次握手 来建立TCP连接，四次挥手 来释放TCP连接，保证建立的传输信道可靠。 采用 连续ARQ协议 （Go-Back-N；超时自动重传）来保证数据传输的正确性。 采用 滑动窗口协议 来保证接收端能够及时处理接收到的数据，进行 流量控制。 采用 慢开始、拥塞避免、快重传、快恢复 来进行 拥塞控制，避免网络拥塞。 TCP 连接控制机制建立TCP连接：三次握手&nbsp;&nbsp;&nbsp;&nbsp; TCP需要三次握手才能在两个进程间建立连接，初始状态发送端，接收端都是 CLOSED 状态，建立连接过程如下： 第一次握手：&nbsp;&nbsp; 发送端发出建立连接请求报文段，其中 SYN=1，ACK=0，Seq=x，自己进入 SYN-SENT （同步已发送）状态，等待确认。&nbsp;&nbsp; 接收端则一直处于 LISTEN 状态，等待发送端发来建立连接请求。 第二次握手：&nbsp;&nbsp; 接收端收到连接请求报文段后，如果同意建立连接，则向发送端发送确认报文段，其中 SYN=1，ACK=1，Ack=x+1，同时设置自己的初始序列号 Seq=y，进入 SYN-RCVD （同步收到）状态，等待发送端确认。 &nbsp;&nbsp; 此时，接收端为该TCP连接分配 TCP缓存和变量（发送端在第三次握手完成后分配），记录了发送端的请求信息，如果没有收到发送端的第三次回话，就会在一段时间内 缓存TCP信息，这也是黑客攻击服务器的 SYN洪泛攻击。 第三次握手：&nbsp;&nbsp; 发送端收到接收端的确认报文后，再次向接收端回复确认报文段，其中 ACK=1，Seq=x+1，Ack=y+1，然后进入 ESTABLISHED （已建立连接）状态。&nbsp;&nbsp; 接收端收到发送端的确认报文后，自己也进入 ESTABLISHED （已建立连接）状态。三次握手完成，可以传输数据。 为什么需要三次握手进行连接？&nbsp;&nbsp; 即为什么发送端还要再次发送确认报文，进行第三次握手？因为这是为了 防止已失效的请求连接报文段突然又传送到接收端，从而产生错误，具体情况如下： 由于存在超时重传功能，如果发送端发出的报文在传输途中滞留，未到达接收端，发送端会再次发送该报文段； 若本次发送完成TCP连接断开后，之前滞留的报文段又到达了接收端，接收端以为是发送端发起的新连接请求，于是向发送端发回确认建立连接报文段，进入 ESTABLISHED 状态；发送端并未发起该请求，且已断开TCP连接，处于 CLSOED 状态。 而接收端以为新连接已建立，不仅缓存报文中的TCP信息，还一直等待发送端发送数据，造成资源浪费。 断开TCP连接：四次挥手&nbsp;&nbsp;&nbsp;&nbsp; 断开TCP连接需要四个步骤，因此被称为四次挥手。与三次握手相对应，初始状态，假设客户端是发送端，服务端是接收端，初始状态双方都处于 ESTABLISHED 状态，等待数据传输完毕，具体过程如下： 第一次挥手：&nbsp;&nbsp; 客户端首先主动关闭，并向服务端发送释放连接请求报文段，其中 FIN=1，Seq=u，并且自己进入 FIN-WAIT-1 （终止等待1）状态，等待服务端回应。 第二次挥手：&nbsp;&nbsp; 服务端收到释放连接请求报文段后，向客户端发回确认报文段，其中 ACK=1，Seq=v，Ack=u+1，随后进入 CLOSE-WAIT （关闭等待）状态。&nbsp;&nbsp; 客户端收到服务端的确认报文段后，进入 FIN-WAIT-2 （终止等待2）状态，等待服务端发出连接释放报文段。 &nbsp;&nbsp; TCP服务端进程收到客户端的释放连接请求后，应该立即通知上层应用，从客户端到服务端的连接将马上释放，TCP连接处于 半关闭(half-close) 状态。此时客户端已经没有数据发送，但是服务端若发送数据，客户端依然接收，这也是为什么第三次挥手是服务端发出。 第三次挥手：&nbsp;&nbsp; 服务端若已经没有向客户端发送的数据，其应用进程就通知TCP释放连接，服务端向客户端发送释放连接报文段，其中 FIN=1，ACK=1，Seq=w，Ack=u+1，随后进入 LAST-ACK （最后确认）状态。 第四次挥手：&nbsp;&nbsp; 客户端在收到服务端的释放连接请求报文段后，向其发回确认报文，其中 ACK=1，Seq=u+1，Ack=w+1，随后进入 TIME-WAIT （时间等待）状态，经过时间等待计时器设置的时间 2MSL 后，才进入 CLOSED 状态。&nbsp;&nbsp; 服务端收到客户端的确认报文后，进入 CLOSED （关闭）状态。 四次挥手的原因？&nbsp;&nbsp; 四次挥手，可以看作两个两次握手的过程，分别是客户端请求释放连接 和 服务端请求释放连接。由于TCP协议是 全双工模式，所以客户端发送释放连接请求报文，只说明客户端已没有数据发送，而它还可以接收服务端的数据传输；所以只有当客户端，服务端都发送释放连接请求时，才能说明双方都没有数据传输，可以结束连接。三次挥手会造成主动关闭那一方的结束报文长时间未得到响应，而超时重传，造成资源浪费。 客户端最后一次发送确认报文段后，为什么还需要等待2MSL时间？ 为了 让服务端能够按照正常步骤进入 CLOSED 状态。因为最后一次确认报文如果丢失，可以触发超时重传机制，不会让服务端无限等待。 为了 防止已失效的请求连接报文段出现在下次连接中。在等待时间内，本次连接的所有报文都已经从网络中消失，从而不会出现失效的报文出现在下次连接中。 TCP 连接控制特例：同时打开，同时关闭&nbsp;&nbsp;&nbsp;&nbsp; 上述内容只总结了TCP连接控制中最常见的三次握手和四次挥手方式。但需要再次强调：TCP是全双工模式，所以存在客户端和服务端同时执行主动打开并连接对方，或者同时执行主动关闭连接的情况存在，这时的执行流程和平常不同。 &nbsp; 1. 同时打开&nbsp;&nbsp;&nbsp;&nbsp; 同时打开连接，指的是通信双方在收到对方的 SYN 包之前，都进行了主动打开的操作并发出自己的SYN包，即：双方同时请求对方建立TCP连接。这种场景在实际情况中比较难发生，因为通信双方必须 同时知道对方的IP地址和端口信息 才可以。其与常见的三次握手区别如图： 通信双方都是发送端，也是接收端，我们统称为客户端。它们都执行主动打开操作。 两端的变化过程都是：CLOSED -&gt; SYN-SENT -&gt; SYN-RCVD -&gt; ESTABLISHED。 建立连接的过程中需要四个数据包的交换，每个数据包都包含SYN，知道SYN收到ACK为止。 虽然是同时打开连接，但是最终建立的仅有 一条TCP连接，而不是两条连接。 &nbsp; 2. 同时关闭&nbsp;&nbsp;&nbsp;&nbsp; 同时关闭连接，指通信双方在收到对方的 FIN 包之前，都进行了主动关闭的操作，并发出自己的 FIN 包，即：双方同时请求对方关闭TCP连接。这个过程相对于同时打开的四个步骤基本相似，需要注意二者的状态变化。关闭连接过程如图： 通信双方都主动执行关闭操作，统称客户端。 两端的变化都是 ESTABLISHED -&gt; FIN-WAIT-1 -&gt; CLOSING -&gt; TIME-WAIT -&gt; CLOSED。与四次挥手相比，状态变化还是有些许不同。 TCP 流量控制机制&nbsp;&nbsp;&nbsp;&nbsp; 三次握手和四次挥手，保证建立的传输信道可靠，而在数据传输过程中，我们也需要采取措施保证数据传输的正确性。&nbsp;&nbsp;&nbsp;&nbsp; 由于双方通信时，发送方的发送速率和接收方的接收速率不一定相等，如果发送方发送过快会导致接收方数据处理不及时，这时无法处理的数据就会存储在缓存区里（失序的数据报也会存在这里）。如果缓冲区已满，而发送方仍然在发送数据，这是接收方只能将溢出的数据包丢弃，造成大量丢包，浪费网络资源。&nbsp;&nbsp;&nbsp;&nbsp; 所以需要进行流量控制，即控制发送方的发送速率，使双方处于动态平衡。连续ARQ协议 和 滑动窗口协议，可以通过对接收端的接收窗口大小，来决定发送端的发送速率，从而进行流量控制，保证数据传输的正确性。 ARQ 协议&nbsp;&nbsp;&nbsp;&nbsp; ARQ协议，即自动重传请求，是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过 确认和超时 两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送一段时间后没有收到ACK确认包，它通常会重新发送。&nbsp;&nbsp;&nbsp;&nbsp; ARQ协议包括 停止等待ARQ协议 和 连续ARQ协议，拥有错误检测，正面确认，超时重传，负面确认及重传机制，TCP协议使用连续ARQ协议。 停止等待ARQ协议&nbsp;&nbsp;&nbsp;&nbsp; 利用停止等待ARQ协议传输数据的过程中，有以下几种情况发生，由于TCP是全双工模式，所以为了简化理解，只考虑一方发送，一方接收的情况。客户端是发送方，服务端是接收方。 &nbsp; 1. 无差错情况 客户端发送数据报文段 M1，发送完 暂停发送，等待服务端确认。 服务端收到报文段 M1，向客户端发送确认报文段。 客户端收到 M1 的确认报文段后，再发送下一个报文段，直到所有报文段依次发送完毕。 &nbsp; 2. 出现差错 如果客户端在发送过程中出现差错，接收端在接收 M1 报文段时检测出差错，就 丢弃报文段 M1，停止操作，服务端不发送任何信息。 客户端等待一段时间后，未收到确认报文段，则认为刚才的报文段丢失并重新发送，实现 超时重传。 需要注意的是： 发送方在发送报文段时，必须要保留已发送的报文段副本，收到确认报文段后删除。 发送报文段和确认信息有各自的编号，来标识每一个报文段和确认信息。 超时计时器的设置时间 &gt; 报文段传送的往返时间。 超时重传机制 的原理：发送方发送完报文段后，设置一个 超时计时器，在计时器到期之前未收到接收方的确认报文段，就会超时重传；若收到确认报文段，撤销该计时器。 &nbsp; 3. 确认丢失和确认延迟&nbsp;&nbsp;&nbsp;&nbsp; 差错不只出现在客户端，服务端也有可能出现，确认丢失和确认延迟就是服务端的确认报文段出现问题导致的。 如果服务端发出的确认报文段丢失，那么客户端在超时重传时间内没有收到确认信息，它会重传该报文段。此时服务端会采取两个行动： 丢弃报文段 M1，不向上层交付。（之前已经接收过 M1 报文段） 向客户端重新发送确认报文段。（A重发报文段，说明重传时间内没有收到确认信息） 如果服务端发出的 确认报文段延迟，没有丢失，只是在超时计数器过期后才送达。此时： 客户端首先启动超时重传，重传 M1 报文段。 服务端收到重复的 M1，丢弃该报文段，重传确认报文段 M1。 客户端收到迟延的确认报文M1，接收后 不做操作，只有重传确认报文段M1到达后，才发送下一报文段。 &nbsp;&nbsp;&nbsp;&nbsp; 有了确认和超时重传机制，就可以实现在不可靠的网络上实现可靠的传输。但是停止等待ARQ协议仍有缺陷，信道利用率低。 字段 描述 TD 报文段发送的时间 RTT 往返时延，发送端的数据报文段发出后开始，到收到确认报文段为止 TA 确认报文段发送的时间 信道利用率 U = TD / (TD + RTT + TA) 连续ARQ协议&nbsp;&nbsp;&nbsp;&nbsp; 连续ARQ协议，是在停止等待ARQ协议的基础上改进，优化其信道利用率太低的问题。这个协议会连续发送一组数据包，然后再等待这些数据包的确认信息ACK。&nbsp;&nbsp;&nbsp;&nbsp; 连续ARQ协议通常是与 滑动窗口协议 一起使用的，发送方需要一直维持一个发送窗口，该窗口大小和连续ARQ协议指定的连续发送数据包个数相同： 位于发送窗口内的报文段，都可以连续发送出去，不需要等待对方的确认，提高了信道利用率。 连续ARQ规定，发送方每收到一个确认报文段ACK，就把发送窗口向前滑动一个报文段。 接收方有接收窗口，采用 累积确认 的方式接收数据包。在收到几个连续的数据包后，对按序到达的最后一个数据包发送确认信息。 接收方累积确认机制很容易实现，并且确认包丢失也不用重传，但是缺点是不能正确地告知发送方，接收方已经收到的数据包信息。 滑动窗口协议&nbsp;&nbsp;&nbsp;&nbsp; 滑动窗口协议，是指在发送方和接收方之间各自维持一个滑动窗口，发送方是发送窗口，接收方是接收窗口，该窗口随着时间变化向前滑动。它允许发送方发送多个数据包，不需要等待确认。TCP的滑动窗口以 字节 为单位。 &nbsp;&nbsp;&nbsp;&nbsp; 滑动窗口规则： 凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传使用。 当发送方收到了接收方的确认报文段，发送窗口才能向前滑动。 发送方发送的数据经过一段时间没有确认(超时计时器控制)，需要使用 Go-back-N 协议，回到最后接收到确认号的地方，重新发送数据。 &nbsp;&nbsp;&nbsp;&nbsp; 滑动窗口机制 1bit滑动窗口协议：发送窗口 = 1，接收窗口 = 1。 Go-back-N 协议：发送窗口 = k，接收窗口 = 1。 选择重传协议：发送窗口 &gt; 1，接收窗口 &gt; 1。 1bit滑动窗口协议&nbsp;&nbsp;&nbsp;&nbsp; 当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为 等待停止ARQ协议，即发送方发送每一个数据包都要停下来，等待接收方发回确认包后才能继续发送下一个。接收方需要判断收到的数据包是新发的，还是重传的，所以发送方要给每一个数据包添加序号，故称 1bit滑动窗口协议。 Go-back-N 协议&nbsp;&nbsp;&nbsp;&nbsp; Go-back-N 协议，表示需要退回来重传已发送过的N个数据包。发送方连续发送若干个数据包，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且发送方在每发送完一个数据帧时都要设置超时定时器。只要在所设置的超时时间内仍未收到确认帧，就要重发相应的数据帧。 比如发送5个数据包，中途第3个数据包丢失，此时接收方只能对前两个数据包发出确认，而不能确定后三个数据包的下落，所以需要发送方重新传输。 选择重传协议&nbsp;&nbsp;&nbsp;&nbsp; 在 Go-Back-N 协议中，接收方如果发现错误数据包，就不再接收后续数据包，然后通知发送方重传错误数据包之后的所有数据包，这样对后续到达的正确数据包造成浪费。在 选择重传协议 中，如果接收方发现某一个数据包出错，继续接收后续数据包，放入缓冲区中不提交，通知发送方重传错误数据包。等到重传数据包到达，将该数据包和缓冲区内的数据包依次交付，但这个方法要求 接收方有足够大的缓冲区。 总结TCP流量控制&nbsp;&nbsp;&nbsp;&nbsp; 所谓的流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。 &nbsp;&nbsp;&nbsp;&nbsp; TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。 &nbsp;&nbsp;&nbsp;&nbsp; 只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。 TCP 拥塞控制&nbsp;&nbsp;&nbsp;&nbsp; 在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这种情况就叫 拥塞。当网络发生拥塞时，会出现数据丢失，时延下降，吞吐量下降，甚至”拥塞崩溃”等情况。&nbsp;&nbsp;&nbsp;&nbsp; 拥塞控制，指为了防止过多的数据注入到网络中，避免出现网络负载过大的情况。它作用于 整个网络，通常就是 对发送方拥塞窗口cwnd的调整。TCP采用拥塞控制的四种算法：慢开始、拥塞避免、快重传、快恢复。 拥塞窗口&nbsp;&nbsp;&nbsp;&nbsp; 发送报文段速率的确定，既要根据接收方的接受能力，又要从全局考虑不要使网络发生拥塞，所以需要接收窗口和拥塞窗口两个状态量决定，单位是字节。&nbsp;&nbsp;&nbsp;&nbsp; 接收窗口，接收方根据当前接收缓存区的大小更新窗口值，是来自接收方的流量控制。&nbsp;&nbsp;&nbsp;&nbsp; 拥塞窗口，发送方根据自己所估计的网络拥塞程度更新窗口值，是来自发送方的流量控制。即发送方的发送窗口。 超时重传机制&nbsp;&nbsp;&nbsp;&nbsp; 超时重传，指的是发送方在发送一个数据包后，开启一个计时器，在一定时间内没有收到接收方的 ACK确认恢复包，认为该数据包丢失并重新发送，直到发送成功为止。该等待时间被称为 RTO。 慢开始算法&nbsp;&nbsp;&nbsp;&nbsp; 当TCP连接刚建立或连接超时，进入慢开始阶段。算法思路是：初始状态不发送大量数据，先探测网络的拥塞程度，再由小到大逐渐增大拥塞窗口大小。 &nbsp;&nbsp;&nbsp;&nbsp; 新建TCP连接时，发送方的拥塞窗口被初始化为 1 个数据包大小（字节），按照其大小发送数据，每收到一个 ACK 确认包就增加数据包发送量，其中拥塞窗口随RTT呈 指数级 增长。即：每经过一次传输，拥塞窗口就加倍增大。但为了防止拥塞窗口的增长引起网络拥塞，发送方还需要维持另一个变量：慢开始门限 ssthresh。 拥塞窗口 &lt; 慢开始门限：使用 慢开始算法。 拥塞窗口 &gt; 慢开始门限：使用 拥塞避免算法。 拥塞窗口 = 慢开始门限：使用 慢开始算法或拥塞避免算法。 &nbsp;&nbsp;&nbsp;&nbsp; 慢开始算法的作用：将拥塞窗口按指数级从小扩大，避免一开始就向网络中注入过多数据包导致拥塞；在拥塞窗口慢慢增大的过程中，如果发现拥塞，可以及时降低发送速度，从而减缓网络拥塞。 拥塞避免算法&nbsp;&nbsp;&nbsp;&nbsp; 当TCP发送方发现超时，或者收到 **3** 个相同的ACK确认包，即认为网络即将发生拥塞，此时进入拥塞避免阶段。 &nbsp;&nbsp;&nbsp;&nbsp; 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT，发送方的 拥塞窗口cwnd加1，而不是加倍，加法增加。拥塞窗口变化过程如下： 在拥塞避免阶段，慢开始门限是拥塞窗口的一半： ssthresh = cwnd / 2，即 乘法减小。 当发生超时，cwnd = 1，此时： 若 cwnd &lt; ssthresh，TCP重新进入 慢开始过程。 若 cwnd &gt;= ssthresh，则执行 拥塞避免算法。 即：拥塞窗口cwnd每次收到 1 个ACK确认包，只增加 1 / cwnd 个数据包大小。 拥塞避免算法的作用：使拥塞窗口以线性方式增长，非指数级增长，使得网络更不容易拥塞。 **慢开始算法和拥塞避免算法**，又称 `加法增大乘法减小算法`。 * 加法增大：指的是拥塞避免算法，使拥塞窗口以线性方式增长。 * 乘法减小：指不管是慢开始算法，还是拥塞避免算法，只要判断网络发生拥塞(没有收到ACK)，慢开始门限 ssthresh 会变成当前拥塞窗口 cwnd 的一半，并且把拥塞窗口设为 1 ，执行慢开始算法。 快速重传算法&nbsp;&nbsp;&nbsp;&nbsp; 在拥塞避免阶段，当数据包超时时，拥塞窗口大小被置为1，重新进入慢启动阶段，这回导致过大减少发送窗口而降低TCP连接的吞吐量，所以引入了快速重传和快速恢复机制。 &nbsp;&nbsp;&nbsp;&nbsp; 快速重传，要求接收方在收到一个失序的报文段后就立即发出重复确认，目的是让发送方及早知道接收方有报文段未收到，而不要等到自己发送数据时捎带确认。&nbsp;&nbsp;&nbsp;&nbsp; 算法规定：发送方只要一连收到 3 个重复确认包，就判定数据包丢失，立即重传丢失的包，而不必等待重传计时器过期。步骤如下： 慢开始门限 ssthresh 设置为 cwnd 的一半。 cwnd 设置为 ssthresh 的值（具体实现有的为 ssthresh + 3）。 重新进入 拥塞避免阶段。 &nbsp;&nbsp;&nbsp;&nbsp; 如图，接收方接收到 M2 后发回ACK确认包，M3 在中途丢失，所以即使收到M4，M5，M6 也不能确认后续报文到达。本来接收方可以什么也不做，也可以发送对 M2 的确认，快速重传机制要求接收方必须重发ACK确认包，这样发送方连续收到3个后就会立即重传，避免阻塞，提高网络吞吐量。 快速恢复算法&nbsp;&nbsp;&nbsp;&nbsp; 快速恢复算法，一般与快速重传算法一起使用。快速恢复算法认为，当发送方收到3个重复的ACK确认包时，TCP不会立即进入拥塞避免阶段，而是进入快速恢复阶段。&nbsp;&nbsp;&nbsp;&nbsp; 其算法思想是：数据包守恒 守则，即同一时刻在网络中的数据包数量是恒定的，只有当旧数据包离开网络，才能发送新数据包。如果发送方收到一个重复的ACK确认包，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是 cwnd+1。拥塞控制的目的，就是修正违反该原则的地方。算法步骤如下： 收到3个重复ACK确认包，执行 “乘法减小“，慢开始门限 ssthresh 设置为 cwnd 的一半。 cwnd 设置为 ssthresh + 3，然后重传丢失的报文段。（+3是因为收到了3个重复ACK包，有3个旧数据包离开网络） 再收到重复的ACK确认包，拥塞窗口 cwnd + 1。 当收到新数据包的ACK确认包，cwnd的值设置为执行乘法减小后ssthresh的值，进入拥塞避免状态。（丢失数据已收到，恢复过程结束） TCP 定时器 名称 时间 描述 建立连接定时器 3s 建立TCP连接时，发送方发送SYN时使用 重传定时器 TCP发送数据时设定 在计时器超时后没有收到返回的确认ACK，发送端就会重新发送队列中需要重传的报文段 延迟应答定时器 &gt; 200ms 接收方收到数据包后，等待一段时间再发送ACK确认包，若接收方有数据发送可以和ACK一起发回 坚持定时器 &lt;= 60s 当发送方收到接收方 0窗口 确认时启动，用来发送探测报文段，确认接收窗口是否增大，再重传数据包 保活定时器 2h 接收方没收到数据包，就将该定时器复位。若超过2小时没有数据传输，则发送探测报文段(间隔75s)；若连发10个探测报文段还没有收到数据包，则中止连接。缺陷明显，建议自己实现心跳包 FIN_WAIT_2 定时器 TCP断开连接时设定 主动关闭的一方收到对方的确认报文段后启动，如果对方仍未发送请求断开数据包FIN，则释放连接 TIME_WAIT 定时器 2MSL 为了让接收方能够按照正常步骤进入 CLOSED 状态。为了防止已失效的请求连接报文段出现在下次连接中 面试题 问题1：UDP和TCP的简单介绍答：UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP 数据报。TCP面向流字符，应用程序产生的全体数据与真正发送的单个IP数据报可能没什么联系。 问题2：UDP的校验和怎么计算？答：UDP的校验和要计算首部和数据部分。首部还包括伪首部 12 字节，其中 UDP长度计算2次。 问题3：UDP校验和为什么要加上伪首部？答：为了让UDP两次检查数据是否已经正确到达目的地。IP接收正确的目的地址，传送到正确的上层程序。 问题4：TCP通过哪些方式保证可靠性？答：1. 分割数据报，TCP将引用数据分割成最适合发送的数据段。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. 确认机制，发送数据报文段后等待确认。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. 重发机制，没有收到确认包，重发数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. 检验和检查，保持数据丢的正确性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. 排序，丢弃重复包，流量控制，拥塞控制。 问题5：TCP和UDP的区别？答：1. TCP面向连接，UDP面向无连接。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. TCP面向报文段，UDP面向字节流。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. TCP提供可靠的传输服务(顺序性，正确性)，UDP传输不可靠。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. TCP传输速度慢，UDP传输速度快。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. TCP对系统资源要求多(首部开销大)，UDP要求少。 问题6：TCP、UDP为什么存在伪首部？答：TCP(UDP)校验和，是根据 TCP(UDP) 数据报的伪报头计算得到的差错检验值。伪报头包含源IP地址和目的IP地址，以及来自IP数据报报头的协议。可以检验IP是否接收了正确的目的地址。伪报头不会再网络中传输，校验和中包含的伪报头内容可以避免目的端错误地接收数据报。 问题7：为什么要3次握手，4次挥手？答：1. 三次握手：为了防止过期的连接请求报文段突然传送到接收端，产生错误。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. 四次挥手：为了确保数据完成传输。关闭连接时如果收到对方的FIN报文通知，仅仅表示对方没有数据发送了，但是己方仍然可以发送数据，所以需要己方发回FIN报文，完成连接关闭。 书签计算机网路-传输层详解UDP协议的详细解析传输层详解TCP三次握手建立连接TCP四次握手释放连接TCP连接的同时打开和同时关闭TCP连续ARQ协议和滑动窗口协议TCP的拥塞控制计算机网络传输层知识点全覆盖TCP拥塞控制：慢开始、拥塞避免、快重传、快恢复TCP中的7种定时器详解","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"计算机网络总结 —— 网络层","slug":"计算机网络总结-——-网络层","date":"2019-11-17T06:42:54.000Z","updated":"2019-11-17T07:26:52.117Z","comments":true,"path":"2019/11/17/计算机网络总结-——-网络层/","link":"","permalink":"http://yoursite.com/2019/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93-%E2%80%94%E2%80%94-%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"前言&nbsp;&nbsp;&nbsp;&nbsp; 数据链路层篇总结了TCP/IP协议体系的认知，对网络体系有初步的了解；也介绍了数据链路层的以太网帧格式及ARP协议相关，明白数据链路层如何将数据帧发往其他设备。这部分内容需要重点学习 ARP协议及ARP查询原理。接下来介绍网络层相关内容：IP协议和ICMP协议，这是TCP/IP体系中的一大支柱。","text":"前言&nbsp;&nbsp;&nbsp;&nbsp; 数据链路层篇总结了TCP/IP协议体系的认知，对网络体系有初步的了解；也介绍了数据链路层的以太网帧格式及ARP协议相关，明白数据链路层如何将数据帧发往其他设备。这部分内容需要重点学习 ARP协议及ARP查询原理。接下来介绍网络层相关内容：IP协议和ICMP协议，这是TCP/IP体系中的一大支柱。 网络层&nbsp;&nbsp;&nbsp;&nbsp; 网络层实现数据包的选路和转发。WAN(广域网) 通常使用众多分级的路由器来连接分散的主机或 LAN(局域网)，因此，通讯的两台主机 一般不是直接相连的，二是通过多个中间结点 (路由器)连接。网络层的任务就是选择这些中间结点，确定两台主机之间的通讯路径。 IP 协议概述&nbsp;&nbsp;&nbsp;&nbsp; IP协议是 TCP/IP协议族 的核心协议，主要包含两个方面： 1. IP首部格式。 2. IP数据报的路由和转发，即IP选路的实现。 它为上层提供 无状态、无连接、不可靠 的服务。 无状态：指IP通信双方 不同步传输数据的状态信息，因此所有IP数据报的发送、传输、接收都是相互独立的。 优点：简单、高效，通信时无需分配过多资源。 缺点：无法处理乱序、重复的IP数据报。 无连接：指IP通信双方都 不长久地维持双方任何信息，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。 不可靠：指IP协议 不能保证IP数据报准确地到达接收端，很多情况都可以导致IP数据报发送失败，而且IP协议不负责重新传输。因此，使用IP服务的上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。 IP 报文首部格式&nbsp;&nbsp;&nbsp;&nbsp; 深入剖析IP协议，大部分时间都是深入剖析IP头部协议，因此IP协议可以分为 IPv4 和 IPv6 两大版本来进行分析。 IPv4&nbsp;&nbsp;&nbsp;&nbsp; IPv4中规定IP地址长度为 32， 可提供 $2^{32}$ 个地址，目前已快耗尽。使用地址解析协议 ARP ，其报文首部由 固定部分(20字节) + 可变部分 组成，格式如下，涂色部分需要重点理解： table th:last-of-type { width: 500px; } 字段 位数 描述 版本号 4 通信协议的版本，通信双方的IP协议 必须一致 首部长度 4 在IPv4中规定地址长度为32位(4字节)，IP首部固定20字节，所以4位最大值1111(15)×4 = 60字节。即：IP首部最长60字节，最短20字节。首部长度是 4 字节的整数倍，会自动补齐 服务类型 8 无用，自动占8位 总长度 16 IP数据报 首部 + 数据 的字节总长度。最大值 $2^{16}-1 = 65535$，超出部分会分片 标识 16 IP在存储器中的 IP数据报计数器，每产生一个IP数据报，计数器+1并赋值给标识字段。分片时标识统一复制，重组时相同标识的IP数据报合并 标志 3 一般高两位有用。高位 MF：MF=1，表示后续仍有分片，MF=0，表示这是最后一份分片。中间位 DF：DF 表示 不能分片，DF=0才能分片 片偏移 13 分片后，该片在原分组的相对位置，实际偏移为偏移量左移3位(乘8)后得到。基本单位是 8 字节，即每个分片长度是 8 字节整数倍，不够填充 生存时间 TTL 8 即数据报可以经过路由器的数量，最大值位 $2^{8}-1=255$个 协议 8 区分上层协议，ICMP是1，TCP是6，UDP是17 首部校验和 16 发送端：校验和置0，其他首部数据 反码相加，结果放入校验和；接收端：首部数据和校验和 一起反码相加，结果为1保留数据报，否则丢弃 IP 源地址 32 将网络字节顺序转化位主机字节顺序，即：每4字节，1&lt;-&gt;4，2&lt;-&gt;3，互换 目的地址 32 转换方法和源IP地址一样 IPv6&nbsp;&nbsp;&nbsp;&nbsp; 和 IPv4 相比，IPv6 将原来的 32 位地址空间增大到 128 位，即可以指定 $2^{128}$ 个地址。使用 多点传播 Neighbor Solicitation 消息 取代 ARP 协议，其首部格式变更如下： IPv6首部 IPv4首部 位数 描述 版本 版本 4 IP协议的版本，IPv4为4，IPv6为6 通信量类 服务类型 8 无用，自动占8位 流标号 无 20 准备用于服务质量控制，且 流标号、源地址、目的地址完全一致，才认为是一个流 有效载荷长度 总长度 16 IPv6的 扩展首部 + 数据 长度，即有效载荷长度 下一个首部 协议 8 区分上层协议，通常为TCP或UDP。有扩展首部时，表示第一个扩展首部的协议类型 跳数限制 生存时间TTL 8 IP数据报可经过路由的数量，最大为 255 个 首部长度 首部长度 0 IPv6基本首部长度 固定为40字节 扩展首部 标识，标志，片偏移 0 IPv6中将这三个字段移至扩展首部中 可选字段 可选字段 0 功能归并在扩展首部 首部校验和 首部校验和 0 取消首部校验，加快路由器对数据报的处理速度。在数据链路层，发现差错的帧直接抛弃；运输层中，TCP发现差错会重传，UDP发现差错会抛弃。 IP 分片&nbsp;&nbsp;&nbsp;&nbsp; 当IP数据报的长度超过帧的 MTU 时，它将被分片传输。分片可能发生在传输过程的任何一个结点，只有在目的主机上才会将分片重组。 &nbsp;&nbsp;&nbsp;&nbsp; 无论是IPv4协议还是IPv6协议，都在IP首部中提供了IP分片和重组的信息字段：数据报标识、标志、片偏移。IP数据报的每个分片都有自己的IP首部，它们的 标识值相同，片偏移不同，标志位除了最后一个分片为0，其他都为1。 &nbsp;&nbsp;&nbsp;&nbsp; 以太网帧的MTU为 1500 字节，除去IP首部的20字节，剩下 1480 字节是IP数据报的数据部分。若现在用其封装一个 1481 字节的ICMP报文，由于ICMP首部占用 8 字节，所以数据部分为 1473 字节，那么在传输过程中必须分片： &nbsp;&nbsp;&nbsp;&nbsp; 1481字节的ICMP报文，需要用 1481 字节的IP数据部分封装，所以需要将其分成 1400 字节和 1 字节 两部分传输。 IP 选路&nbsp;&nbsp;&nbsp;&nbsp; IP选路，即IP寻路，根据路由表中的记录，来决定当前数据报是直接交付（目的地址属于当前网络），还是发往下一跳路由（隶属于不同的局域网）。 IP 层工作流程&nbsp;&nbsp;&nbsp;&nbsp; 当IP模块接收到来自数据链路层的IP数据报时，它首先对首部进行 CRC校验，确认无误后开始分析首部信息。&nbsp; 1. 如果该IP数据报的头部设置为 源站选路 选项，则IP模块调用 数据报转发 子模块来处理。 &nbsp; 2. 如果该数据报中 目的IP地址 是 本机IP地址或是某个广播地址，即数据发给本机，则IP模块根据首部中的 协议字段 来决定将其发送给哪个上层应用（TCP/UDP/ICMP）；如果不是发送给本机，则调用 数据报转发 模块处理。 &nbsp; 3. 数据报转发子模块首先检查系统是否允许转发，不允许则丢弃该数据报；允许则对其执行一些操作后，交给 IP数据报输出 子模块。 &nbsp; 4. IP路由过程，由 计算下一条路由 模块实现，它指导IP数据报应发往哪个下一条路由（或目标主机），以及经过哪些网卡发送。IP模块实现数据报路由的核心结构是 路由表，它按照数据报的 目标IP地址 分类，同一类型的IP数据报被发往相同的下一跳路由器（或目标主机）。 &nbsp; 5. IP输出队列 中存放所有 等待发送 的IP数据报，其中除了需要转发的IP数据报外，还封装了 本机上层数据（ICMP报文、TCP报文、UDP数据报）的IP数据报。 &nbsp; 6. 虚线箭头显示了路由表更新的过程。由 路由协议 和 route命令 调整路由表，使之更适应最新的网络拓扑结构，即 IP路由策略。 IP 路由机制&nbsp;&nbsp;&nbsp;&nbsp; 要了解IP路由机制，首先要熟悉IP路由表的结构： 字段 描述 Destination 目标网络或主机 Gateway 网关地址，*表示目标和本机在同一网络中，不需要路由 Genmask 网络掩码 Flags 路由项的标志，常见标志有5种（其他在route命令的man手册） U，该路由项是活动的； H，该路由项的目标是一台主机； G，该路由项的目标是网关（路由器）； D，该路由项是由重定向生成的； M，该路由项被重定向修改过； Metric 路由距离，即到达指定网络所需的 中转数 Ref 路由项被引用的次数 Use 该路由项被使用的次数 Iface 该路由项对应的输出网卡接口 &nbsp;&nbsp; 其中 H 和 G 十分重要： H：目的地址是一个完整的主机地址，没有设置表明目的地址是一个网络地址。（子网掩码决定，主机号部分为0） G：区分了间接路由和直接路由。 直接路由，不仅有目标的IP地址，还有其数据链路层地址；简介路由，有目标IP地址，而数据链路层地址是 网关。 &nbsp;&nbsp; IP路由机制，即给定数据报的目标IP地址，它将匹配路由表中的某项记录，找到目标网络或主机的过程。基本查找方法分为三个步骤：&nbsp; 1. 搜索路由表中匹配的主机IP地址，未匹配跳转步骤2；&nbsp; 2. 搜索路由表中匹配的目标网络IP地址，未匹配跳转步骤3；&nbsp; 3. 选择默认路由项，即数据报下一跳路由是网关。 ICMP 协议&nbsp;&nbsp;&nbsp;&nbsp; 由于IP协议不提供可靠的传输，如果丢包，IP协议并不能通知传输层是否丢包及丢包的原因。ICMP协议完成了这种功能： 确认IP数据报是否成功到达目的地址； 通知在发送过程中IP数据报被丢弃的原因； &nbsp;&nbsp; 需要注意的是，ICMP协议是基于IP协议工作的，它并不是传输层的功能，仍然属于 网络层协议。ICMP 只能搭配IPv4 使用，如果是 IPv6，需要使用 ICMPv6。 ICMP报文格式&nbsp;&nbsp;&nbsp;&nbsp; ICMP报文包含在IP数据报中，IP报文首部在ICMP报文的最前面。一个ICMP报文包括IP首部（至少20字节）、ICMP首部（至少8字节）和ICMP报文（ICMP数据部分）。其中，IP报文的协议字段为 1 时，说明这是一个 ICMP报文。 字段 说明 类型 8位，标识ICMP报文的类型，1~127是差错报文，128意思是诊断查询报文 代码 8位，标识ICMP报文的代码。它与类型字段一起共同标识ICMP报文的详细类型 校验和 对整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错 ICMP分为两大报文：差错报文，诊断查询报文。类型及含义如下： 类型（十进制） 内容 0 回送应答 3 目标不可达 4 原点抑制 5 重定向 或 改变路由 8 回送请求 9 路由器公告 10 路由器请求 11 超时 17 地址子网请求 18 地址子网应答 查询报文&nbsp;&nbsp;&nbsp;&nbsp; ICMP查询报文分为两大类：request请求报文 和 reply应答报文，类型 8 代表请求，类型 0 代表应答，两种报文的代码都为 0。 &nbsp; 1. 时间戳请求和应答 原始时间戳：源主机给目的主机发送一个数据报的时间点。 接收时间戳：目的主机接收源主机发送的数据报的时间点。 发送时间戳：源主机给目的之际发回 应答报文 的时间点。 发送时间 = 接收时间戳 - 原始时间戳，源主机给目的主机发送数据报花费的时间。 接收时间 = 分组返回时间 - 发送时间戳，目的主机发送应答报文给源主机所用时间。 往返时间 = 发送时间 + 接收时间。 &nbsp; 2. 地址掩码请求和应答&nbsp;&nbsp;&nbsp;&nbsp; 假如主机A知道自己的IP地址，但是不知道子网掩码是多少，主机A就可以通过广播或者组播的形式在网络上发送一个地址掩码请求报文，其他设备收到请求后会发送一个地址掩码回答报文，分两种情况： 主机A知道找谁请求子网掩码：用 单播 的形式发送地址掩码请求，找特定主机请求子网掩码地址。 主机A不知道找谁请求子网掩码：用 广播 的方式请求同一网段下的主机，能提供掩码的主机发送地址掩码应答告诉主机A掩码地址。 地址掩码请求报文中，地址掩码是 0 来填充；地址掩码应答报文中，地址掩码是正确的值。 &nbsp; 3. 路由器询问和通告&nbsp;&nbsp;&nbsp;&nbsp; 当主机A给主机B发送数据报时，必须明确数据报在网络中传输的路线，即经过了哪些路由器转发。如果不知道这些，主机A会以 广播 或者 多播 的形式发送一个 ICMP路由器询问和通告报文，向网络中的设备询问数据报在网络中经过的路线，知道路线的路由器发回一个ICMP路由器通告报文。 生存期：路由器发回给源主机的路由信息的有效时间，超过有效时间则失效。 优先级：地址优先级高的路由器，源主机发送数据报时有很大可能会选择该路线。 差错报文&nbsp; 1. 目标不可达&nbsp;&nbsp;&nbsp;&nbsp; 当路由器发送的数据报不能发送到指定的目的地时，或者不能给数据报找到路由或主机，不能交付数据报时，就丢弃该数据报，然后向发送数据报的源主机发回一个 终点不可达报文。类型标号为 3，代码号0-15，表示有16种具体错误原因。标识符和序列号全用0填充。 常见的不可到达类型为： 网络不可达：代码字段为0 主机不可达：代码字段为1 协议不可达：代码字段为2 端口不可达：代码字段为3，目标系统本地没有此服务。 &nbsp; 2. 源点抑制&nbsp;&nbsp;&nbsp;&nbsp; 源点抑制，是为了弥补IP协议面向无连接，没有流量控制机制而产生的。它为IP报文提供流量监控机制，但是 ICMP源点抑制机制不能控制流量大小，只能根据流量使用情况，给源主机提供一些建议。即：通知数据报在拥塞时被丢弃，并且警告源主机流量出现拥塞，源主机根据该报文做出处理。类型标号 4，代码号 0。 若路由设备A一直堵塞，则一直会给源主机发送ICMP源点抑制报文，直到设备不再堵塞。 &nbsp; 3. 超时&nbsp;&nbsp;&nbsp;&nbsp; 以下几种情况，会发送ICMP超时报文： 路由器接收的数据报 TTL生命周期值为0，路由器会舍弃该数据报，向源主机发送ICMP超时报文； 目标主机在规定时间内 没有收到所有的数据分片，它会把已经收到的所有数据分片丢弃，并想源主机发回ICMP超时报文，防止 路由环路 问题出现。ICMP超时报文，类型值 11，代码为 0 只能给路由器使用，表示TTL值为0；代码为 1 只能给目的主机使用，表示规定时间内目的主机没有收到所有的数据分片。 &nbsp; 4. 参数问题&nbsp;&nbsp;&nbsp;&nbsp; 数据报在网络中传输时，在IP首部出现任何二义性或首部字段值被修改、缺失，路由器或目的主机发现后就丢弃该数据报，并发回参数问题报文。参数报文的类型值为 12，代码值为 0 表示数据报首部字段值被修改；代码值为 1 表示数据报在传输中 要求加上可选字段，而未添加。指针指向出错部分。 &nbsp; 5. 改变路由（重定向）&nbsp;&nbsp;&nbsp;&nbsp; 改变路由报文，是路由器发送给源主机最优传输路径的报文。如主机A和主机B所在网络如下：&nbsp;&nbsp;&nbsp;&nbsp; 数据报文的传输路线：主机A -&gt; R1 -&gt; R2 -&gt; R3 -&gt; R4 -&gt; 主机B，当报文传输到路由器 R3 时，查看自己的路由表 发现下一跳是R4，而R4的接收端口和发送端口与自己一致，此时它会继续将数据报传输给R4，同时给源主机发送ICMP改变路由报文，告知最优路线。即下次传输路线为：主机A -&gt; R1 -&gt; R2 -&gt; R4 -&gt; 主机B。 改变路由报文的类型值为 5，目的路由器的IP地址，即最优路线的IP地址，代码0123含义如下： 0：对某一个特定网络路由器进行改变 1：对某一特定主机进行改变 2：对指定的服务类型和网络路由进行改变 3：对指定的服务类型和主机路由进行改变 一般来说，主机只能接收ICMP重定向报文，路由器只能发送ICMP重定向报文。 面试题总结 问题1：如何理解IP的不可靠和无连接？答：不可靠：指的是不能保证数据能成功地到达目的地。发生错误丢弃该数据报，发送ICMP报文给源主机。可靠性由上层提供。无连接：IP不维护关于后续数据报的状态信息，即IP数据报可以不按顺序发送和接收。 问题2：为什么IP首部中要有总长度字段？答：因为一些数据链路（以太网）需要填充一些数据以达到最小长度。因为以太网帧的最小长度是 46 个字节，但是IP长度可能更短，所以需要总长度来确定IP数据部分的内容。 问题3：IP 首部校验和怎么计算的，与 ICMP，IGMP，TCP，UDP 的首部校验和有什么区别与共同点？答：（1）校验和字段置0；（2）首部每一个进行二进制反码求和；（3）结果存入校验和字段；（4）收到IP数据报后，对首部包括校验和字段进行二进制反码求和；（5）如果结果全为 1，表示正确。否则表示错误，丢弃该数据报，交由上层处理。共同点：计算方法一致。区别：IP计算校验和不算校验码，ICMP，IGMP，TCP，UDP同时覆盖首部和数据检验码。 问题4：主机和路由器的本质区别？答：主机从不把数据报从一个接口转发到另一个接口，都是直接传输。路由器需要转发数据报。 问题5：IP的路由选择过程是？答：根据最长匹配原则，找到条目，发送到指定的路由器。如果不能找到，返回一个 “主机不可达” 或 “网络不可达” 的错误。 问题6：IP路由选择的特性是？答：（1）逐跳进行。IP不知道任何目的地址的完整路径，只提供下一跳地址。（2）为一个网络指定一个路由器，而不是为每个主机指定一个路由器。可以缩小路由表规模。 问题7：IP搜索路由表的步骤是？答：搜索匹配主机地址 -&gt; 搜索匹配目的网络地址 -&gt; 搜索默认路由项。 问题8：如果路由表中没有默认路由项，而且也没有找到匹配项，这时该如何处理？答：取决于该IP数据报是由主机产生，还是被转发的。主机产生的，则给发送该数据报的应用程序返回一个差错，”主机不可达” 或 “网络不可达”。被转发的，则给源主机发送 “主机不可达” 的ICMP差错报文。 问题9：IP地址的分类，如何划分？各类地址支持的主机数？答：A类地址：首位 0， 1.0.0.1 ~ 126.255.255.254，主机号 24 位。B类地址：首位 10， 128.0.0.1 ~ 191.255.255.254，主机号 16 位。C类地址：首位 110， 192.0.0.1 ~ 223.255.255.254，主机号 8 位。D类地址：首位 1110，224.0.0.1 ~ 239.255.255.254，又称多播地址。E类地址：首位 11110， 240.0.0.1 ~ 254.255.255.254，此类地址是保留地址。 问题10：ICMP的主机不可达报文是在什么情况下发出的？答：三层设备（路由器）给该主机寻路时，没有找到相应路径，向源主机发回ICMP主机不可达差错报文。 问题11：ICMP重定向差错报文是怎么来的？在何种场合出现？答：ICMP重定向差错报文，是为了提示源主机有最优传输路径出现。当主机发送IP数据报给路由器R1时，它会检查它的路由表，发现R2时该数据报的下一跳，当它发送给R2的时候，发现发送的接口和接收的端口一致，因此同时发送一个ICMP重定向报文给主机。 问题12：重定向报文有什么规则？答：重定向报文只能由路由器发送，由主机接收。 书签IP协议详解IP协议详解(一)11-ICMP差错报告报文12-ICMP查询报告报文","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"Mysql基础","slug":"Mysql基础","date":"2019-11-12T14:29:07.000Z","updated":"2019-11-15T17:09:54.793Z","comments":true,"path":"2019/11/12/Mysql基础/","link":"","permalink":"http://yoursite.com/2019/11/12/Mysql%E5%9F%BA%E7%A1%80/","excerpt":"前言&nbsp;&nbsp;&nbsp;&nbsp; MySQL是一个关系型数据库管理系统，使用SQL语言访问数据库，体积小、查询速度快、灵活性高，非常适合个人开发时选用其作为数据库。本文梳理了MySQL的基本知识点，帮助巩固数据库基本知识。","text":"前言&nbsp;&nbsp;&nbsp;&nbsp; MySQL是一个关系型数据库管理系统，使用SQL语言访问数据库，体积小、查询速度快、灵活性高，非常适合个人开发时选用其作为数据库。本文梳理了MySQL的基本知识点，帮助巩固数据库基本知识。 SQL分类 类别 描述 包含命令 DDL(数据定义语言) 定义数据库对象，如数据库、表、列等 create，drop，alter DML(数据操作语言) 对数据库中表的数据进行增删改 insert，delete，update DQL(数据查询语言) 查询数据库中表的记录（数据) select，where DCL(数据控制语言) 定义数据库的访问权限和安全级别，及创建用户 grant，revoke DDL：数据定义操作数据库(CRUD)&nbsp;1. C(Create)：创建 create database 数据库名;：创建数据库（默认字符集 var)。 create database if not exists 数据库名;：创建数据库前，先检测是否从重名，重名不报错会出警告；不重名则创建。 create database 数据库名 character set 字符集名;：创建数据库并指定字符集。 &nbsp; 2. R(Retrieve)：查询 SHOW DATABASES;：查询所有数据库的名称。 show create database 数据库名;：查询某个数据库的字符集（创建语句）。 &nbsp; 3. U(Update)：修改 alter database 数据库名 character set 字符集名;：修改数据库的字符集。 &nbsp; 4. D(Delete)：删除 drop database 数据库名;：删除数据库。 drop database if exists 数据库名;：删除数据库前先判断是否存在，存在才删除。 &nbsp; 5. 使用数据库 use 数据库名;：使用数据库。 select database();：查询当前正在使用的数据库。 操作表(CRUD)&nbsp; 1. C(Create)：创建 123456create table 表名 ( 列名1 数据类型1， # 数据库类型：整数类型、小数类型、日期类型、字符串、 列名2 数据类型2， # 二进制、BLOB、CLOB ... 列名n 数据类型n); create table 表名1 like 表名2;：复制表2。 &nbsp; 2. R (Retrieve)：查询 show tables;：查询某个数据库中所有表的名称。 desc 表名;：查询表结构。 show create table 表名;：查询表的创建语句。 &nbsp; 3. U (Update)：修改 alter table 表名 rename to 新表名;：修改表名。 alter table 表名 character set 字符集名;：修改表的字符集。 alter table 表名 add 列名 数据类型;：添加一列。 alter table 表名 change 新列名 新数据类型：修改列名称、类型。 alter table 表名 modify 原列名 新数据类型;：只修改列名的数据类型。 alter table 表名 drop 列名：删除列。 &nbsp; 4. D (Delete)：删除 drop table 表名;：删除表。 drop table if exists 表名;：删除表前先判断是否存在，存在才删除。 DML：增改删表中数据添加数据1insert into 表名(列名1, 列名2, ...., 列名n) values(值1, 值2, ..., 值n); 注意事项: 列名与值，需一一对应； 表名后不添加列名，默认指给所有列添加列名； 删除数据 delete from 表名 [where 条件]：按条件从表中删除数据。 delete from 表名; ：删除表中所有记录，有多少条记录就执行多少次，效率低不推荐。 TRUNCATE table 表名;：删除表，然后在创建一个一模一样的空表，推荐使用该方法。 修改数据 update 表名 set 列名1=值1, 列名2=值2, ... [where 条件];：修改表中记录。 update 表名 set 列名1=值1, 列名2=值2, ...;：不加条件，修改所有记录。 DQL：查询表中的记录语法1234567select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定; 基础查询&nbsp;&nbsp;&nbsp;&nbsp; 现有表如下: &nbsp; 1. 多字段查询：在 select 后的字段列表中写明想查询的字段即可。如查询姓名与年龄： 1select name, age from student; -- 只列出姓名和年龄两列 &nbsp; 2. 去除重复：distinct 关键字可以对查询结果集去重。如查询城市： 1select distinct address from student; -- 查询城市，重复的湖南和香港只保留一个 &nbsp; 3. 计算列：将可计算列的字段，在查询字段列表中用算术符号连接即可。如查询数学和英语成绩之和： 1select name,math,english, math + english from student; -- math + english 作为新列名被查询 注意：如果有 null 参与运算，结果都为 null，MySQL有 IFNULL() 函数来解决该问题。1select name, math, english, math + IFNULL(english, 0) from student; -- 将Null视为0进行计算 &nbsp; 4. 起别名：在字段列表中，某个字段后添加 AS 和新名字即可。如将 math + IFNULL(english, 0) 改为 总分 ： 1select name, math, english, math + IFNULL(english, 0) as 总分 from student; 或者 不使用as关键字，直接空格后添加新名字 也能实现改名功能： 1select name, math, english, math + IFNULL(english, 0) 总分 from student; 条件查询&nbsp; 1. where 子句后跟条件&nbsp; 2. 运算符 比较运算符：&gt;、&lt;、&gt;=、&lt;=、=、&lt;&gt;（不等于）； BETWEEN...AND：在某个*闭区间 *范围内的记录；1select * from student where age between 20 and 50; -- 查询年龄在20到50岁之间的人 IN(集合)：表示多个值，用逗号分隔；1select * from student where age in (20,22,55); -- 查询年龄20岁，22岁，55岁的人 LINK &#39;&#39;：模糊查询；12345select * FROM student WHERE name LIKE &apos;马%&apos;; -- 查询姓马的人，% 表示之后的任意字符SELECT * FROM student WHERE name LIKE &apos;马_&apos;; -- 查询姓马且名字字数为一个字的人， _ 下划线表示一个占位字符SELECT * FROM student WHERE name LIKE &apos;马__&apos;; -- 查询姓马且名字字数为两个字的人， _ 下划线表示一个占位字符 IS NULL：查询某列为 null 的值，不能写=NULL ；123SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩为null的人，不能用运算符进行判断SELECT * from student WHERE english IS NOT NULL; -- 查询英语成绩不为null的人 排序查询&nbsp; 1. 语法：order by 子句 1SELECT * FROM 表名 WHERE 条件子句 ORDER BY 排序字段1 排序方式1, 排序字段2 排序方式2 ... &nbsp; 2. 排序方式： ASC：升序排序，默认方式； DESC：降序排序；123-- 按照数学成绩升序/降序排序SELECT * FROM student ORDER BY math;SELECT * FROM student ORDER BY math DESC; 多字段排序：若某一字段数据相同，则可以按照第二排序字段进行排序。123-- 按照数学成绩、英语成绩进行升序排序SELECT * FROM student ORDER BY math, english;SELECT * FROM student ORDER BY math ASC, english ASC; 聚合函数&nbsp;&nbsp;&nbsp;&nbsp; 聚合函数：将一列数据作为整体，进行纵向计算。 &nbsp; 1. count：计算个数，一般选择非空的列（主键）。 12345SELECT COUNT(列名) FROM 表名; -- 该函数排除null值SELECT COUNT(name) FROM student; -- 计算人数SELECT COUNT(english) FROM student; -- 计算参加英语考试的人数，null值不算SELECT COUNT(IFNULL(english, 0)) FROM student; -- 这样写可以将null值算进去 &nbsp; 2. max：计算最大值； 1SELECT MAX(math) FROM student; -- 计算数学成绩的最大值 &nbsp; 3. min：计算最小值； 1SELECT MIN(math) FROM student; -- 计算数学成绩的最小值 &nbsp; 4. sum：计算总和； 1SELECT SUM(math) FROM student; -- 计算数学成绩的总和 &nbsp; 5. avg：计算平均值； 1SELECT AVG(english) FROM student; -- 计算英语成绩的平均成绩 分组查询&nbsp; 1. 语法： 1SELECT 分组字段、聚合函数 FROM 表名 GROUP BY 分组字段; &nbsp; 2. 案例 1234567891011-- 按照性别分组，分别查询男、女同学的数学平均分SELECT sex, SUM(math) FROM student GROUP BY sex; -- 男，461 女，175-- 按照性别分组，分别查询男、女同学的人数SELECT sex, COUNT(sex) FROM student GROUP BY sex; -- 男，6 女，2-- 按照性别分组，分别查询数学成绩大于70分的男、女同学的人数和平均分SELECT sex, COUNT(sex), AVG(math) FROM student WHERE math &gt; 70 GROUP BY sex; -- 男，3，94.3333 女，2，87.5000-- 按照性别分组，分别查询数学成绩大于70分的男、女同学的人数和平均分，低于70分的不参与分组，分组之后人数大于2人，使用 having 子句进行分组条件限制SELECT sex, COUNT(sex), AVG(math) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(sex) &gt; 2; -- 男，3，94.3333 &nbsp; 3. 注意事项： 分组之后查询的字段：分组字段、聚合函数； WHERE 和 HAVING 的区别？ WHERE 在分组前进行限定，如果不满足条件，则不参与分组；HAVING 在分组之后进行限定，如果结果不满足条件，则不会被查询到。 WHERE 后不可以跟聚合函数；HAVING 后可以跟聚合函数。 分页查询&nbsp; 1. 语法：不同的数据库实现分页的操作不一样，MySQL中分页操作是 LIMIT 。 1LIMIT 开始的索引, 每页查询的条数; -- 公式：开始的索引 = (当前页码-1) * 每页条数; &nbsp; 2. 案例 1234-- 每页显示3条记录，分别查询第一页、第二页、第三页SELECT * FROM student LIMIT 0, 3;SELECT * FROM student LIMIT 3, 3;SELECT * FROM student LIMIT 6, 3; 约束&nbsp; 1. 概念：对表中的数据进行限定，保证数据的正确性、有效性、完整性。&nbsp; 2. 分类： 主键约束：PRIMARY KEY，该列的值 非空且唯一，一张表 有且只有一个主键，是表中记录的唯一标识。 自动增长：如果某一列的数据类型是 数值型，可以使用 auto_increment 关键字使该值根据上一条数据自动增长，一般与主键一起用。 非空约束：NOT NULL，该列的值不能为空。 唯一约束：UNIQUE，该列的值不能重复。 外键约束：FOREIGN KEY。 &nbsp; 3. 添加方式 创建表时添加约束：1234CREATE TABLE stu ( id INT, name VARCHAR(20) 约束名称 -- 约束); 创建表后添加约束：MODIFY 1ALTER TABLE student MODIFY name varchar(20) 约束名称; &nbsp; 4. 特殊约束——外键约束：foreign key ，让表与表产生关系，从而保证数据的正确性。 123456789101112131415-- 现添加表如下：create table emp ( id int primary key auto_increment, name varchar(30), age int, dep_name varchar(30), dep_location varchar(30));INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;张三&apos;,20,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;李四&apos;,21,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;王五&apos;,20,&apos;研发部&apos;,&apos;广州&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;老王&apos;,20,&apos;销售部&apos;,&apos;深圳&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;大王&apos;,22,&apos;销售部&apos;,&apos;深圳&apos;);INSERT INTO emp (name, age, dep_name, dep_location) VALUES (&apos;小王&apos;,18,&apos;销售部&apos;,&apos;深圳&apos;); 可以发现，’研发部’,’广州’ 和 ‘销售部’,’深圳’ 多此出现，造成数据冗余，所以可以将该表拆分为两个表： 1234567891011121314151617181920212223242526-- 解决方法，将表拆分成两张表：部门表和员工表-- 部门表，主表create table department ( id int PRIMARY KEY auto_increment, dep_name varchar(20), dep_location varchar(20));-- 员工表，从表create table employee ( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 外键对应主表的主键 constraint dep foreign key (dep_id) references department(id));-- 添加两个部门INSERT INTO department VALUES (null,&apos;研发部&apos;,&apos;广州&apos;), (null,&apos;销售部&apos;,&apos;深圳&apos;);-- 添加员工INSERT INTO employee (name, age, dep_id) VALUES (&apos;张三&apos;, 20, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;李四&apos;, 21, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;王五&apos;, 20, 1);INSERT INTO employee (name, age, dep_id) VALUES (&apos;老王&apos;, 22, 2);INSERT INTO employee (name, age, dep_id) VALUES (&apos;大王&apos;, 20, 2);INSERT INTO employee (name, age, dep_id) VALUES (&apos;小王&apos;, 18, 2); 其中新表 Department 的主键id，和员工表 Employee 的 dep_id 相互对应，在查询时将两个表以这个关系连接起来，就可以查询到所有员工的全部信息。这里的主表的主键，就是从表的外键。 &nbsp; 1. 添加外键方式： 在创建表时，可以添加外键。12345create table 表名 ( ... 外键列, constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)); 创建表之后，添加外键。1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称); 删除外键：alter table 从表名 drop foreign key 外键名称; &nbsp; 2. 级联操作：在添加外键时设置后，主表主键更改时，从表的记录会实时更新。 级联更新 on update cascade：更改主表主键时，从表的外键会实时更新。1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称) on update cascade; 级联删除 on delete cascade：删除主表主键时，从表的外键关联的记录会实时删除。1alter table 从表名 add constraint 外键名称 foreign key (外键列名称) references 主表名(主表列名称) on delete cascade; 数据库设计多表之间的关系分类及实现关系&nbsp; 1. 一对一&nbsp;&nbsp;&nbsp;&nbsp; 人和身份证的关系，一个人只能由一个身份证，一个身份证只对应一个人。 &nbsp; 2. 一对多(多对一) 关系举例：如部门和员工，一个部门由多个员工，而一个员工只对应一个部门。 实现方式：在多的一方建立外键，指向一的一方的主键，即”多”建立从表，”一”建立主表。 &nbsp; 3. 多对多： 关系举例：学生与课程，一个学生可以选多个课程，一门课程可以被多个学生选择，所以 学生(m) —-&gt; 课程(n)。 实现方式：需要第三张中间表，至少包含两个字段作为第三张表的外键，分别指向两张表的主键。 案例&nbsp;&nbsp;&nbsp;&nbsp; 某旅游网站，有旅游线路分类、旅游线路、用户信息等功能，建立表存储这些信息。&nbsp; 1. 旅游线路分类(1) –&gt; 旅游线路(n)&nbsp; 2. 用户旅游收藏线路(m) –&gt; 旅游线路(n) 12345678910111213141516171819202122232425262728293031323334353637383940-- 创建旅游线路分类表CREATE TABLE tab_category ( cid INT PRIMARY KEY auto_increment, cname VARCHAR (100) NOT NULL UNIQUE);-- 添加旅游线路分类数据INSERT INTO tab_category (cname) VALUES(&apos;周边游&apos;),(&apos;出境游&apos;),(&apos;国内游&apos;),(&apos;港澳游&apos;);-- 创建旅游线路表CREATE TABLE tab_route ( rid INT PRIMARY KEY auto_increment, rname VARCHAR (100) NOT NULL UNIQUE, price DOUBLE, rdate date, cid INT, FOREIGN KEY (cid) REFERENCES tab_category (cid));-- 创建用户表CREATE TABLE tab_user ( uid INT PRIMARY KEY auto_increment, -- uid 用户主键 username VARCHAR (100) NOT NULL UNIQUE, -- username 用户名 PASSWORD VARCHAR (30) NOT NULL, -- password 密码 NAME VARCHAR (100), -- name 真实姓名 birthday date, -- birthday 生日 sex CHAR (1) DEFAULT &apos;男&apos;, -- sex 性别 telephone VARCHAR (11), -- telephone 电话 email VARCHAR (100) -- email 邮箱);-- 创建收藏表，中间表 关联路线表和用户表CREATE TABLE tab_favorite ( rid INT, date datetime, uid INT, PRIMARY KEY (rid, uid), FOREIGN KEY (rid) REFERENCES tab_route (rid), FOREIGN KEY (uid) REFERENCES tab_user (uid)); 范式&nbsp;&nbsp;&nbsp;&nbsp; 概念：设计数据库时需要遵循的一些规范。 各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 其中，第一范式(1NF) ，第二范式(2NF)，第三范式(3NF) 是数据库学习的重点。 第一范式(1NF)&nbsp;&nbsp;&nbsp;&nbsp; 每一列都是不可分割的原子数据项。数据库建出来的表都是符合 1NF 的，以下表为例： 第一范式存在的问题：&nbsp; 1. 存在严重的 数据冗余 ：姓名、系名、系主任、课程名称；&nbsp; 2. 数据添加 存在问题：添加新开设的系和系主任时，添加的数据不合法；&nbsp; 3. 数据删除 存在问题：删除记录时会将系和系主任数据一起删除； 第二范式(2NF)&nbsp;&nbsp;&nbsp;&nbsp; 在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）。 函数依赖：A —&gt; B，如果通过 A 属性的值，可以唯一确定 B 属性的值，则 B 依赖于 A。例如：学号 —&gt; 姓名，系名 —&gt; 系主任。 完全函数依赖：A —&gt; B，如果 A 是 属性组 ，则 B 属性值的确定需要依赖于 A 属性组中 所有属性的值。例如：(学号，课程名称) —&gt; 成绩，单学号/课程名称 无法确定成绩。 部分函数依赖：A —&gt; B，如果 A 是 属性组，则 B 属性值的确定仅依赖于 A 属性组中 某些属性值。例如： (学号，课程名称) —&gt; 姓名，由学号即可确定姓名，不需要课程名称。 传递函数依赖：A —&gt; B，B —&gt; C，如果通过 A 属性的值，可以唯一确定 B 属性的值，通过 B 属性的值，可以唯一确定 C 属性的值，则称 C 传递函数依赖于 A。例如：学号 —&gt; 姓名，姓名 —&gt; 系名，则系名传递依赖于学号。 &nbsp;&nbsp;&nbsp;&nbsp; 所以第二范式在1NF基础上，需要对表进行拆分消除部分函数依赖，以解决1NF的问题。 发现第二范式消除部分函数依赖后，仍存在问题： 数据添加 存在问题：添加新开设的系和系主任时，添加的数据不合法； 数据删除 存在问题：删除记录时会将系和系主任数据一起删除； 即，存在函数传递依赖。 第三范式(3NF)&nbsp;&nbsp;&nbsp;&nbsp; 在 2NF 的基础上，任何非主属性不依赖于其他非主属性（在 2NF 的基础上消除传递依赖）。解决方法：在 2NF 基础上再分一张表如下。 数据库的备份和还原&nbsp; 1. 命令行： 1mysqldump -u用户名 -p密码 数据库名 &gt; 保存路径 -- 备份 还原：登录数据库 –&gt; 创建数据库 –&gt; 使用数据库 –&gt; 执行sql文件&nbsp; 2. 图形化工具 多表查询&nbsp; 1. 查询语法 123456select 列名列表from 表名列表where 条件 &nbsp; 2. 案例，准备sql如下： 1234567891011121314151617181920212223-- 创建部门表CREATE TABLE dept ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));INSERT INTO dept (NAME) VALUES(&apos;开发部&apos;), (&apos;市场部&apos;), (&apos;财务部&apos;);-- 创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3);INSERT INTO emp (NAME, gender, salary, join_date, dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1); 直接查询两张表，结果时两张表的 笛卡尔积： 1select * from emp, dept; 内连接查询&nbsp; 1. 隐式内连接：使用 WHERE 条件消除无用数据。 1234-- 查询每个员工的信息及其就职部门SELECT emp.id, emp.name, gender, salary, join_date, dept.nameFROM emp, deptWHERE emp.dept_id = dept.id; 也可以给表取别名，替换复杂的表名来简化查询语句： 1234-- 查询每个员工的信息及其就职部门SELECT t1.id, t1.name, gender, salary, join_date, t2.nameFROM emp t1, dept t2WHERE t1.dept_id = t2.id; &nbsp; 2. 显式内连接：使用 inner join ... on 来连接两张表 1select 字段列表 from 表名1 inner join 表名2 on 条件; -- inner 可省略 1234-- 查询每个员工的信息及其就职部门，同样也可以给表名取别名SELECT emp.id, emp.name, gender, salary, join_date, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id; &nbsp; 3. 内连接注意事项： 从哪些表中查询数据； 查询条件是什么； 查询哪些字段； 外连接查询&nbsp; 1. 左外连接：使用 left outer join ... on 关键字，查询的是 左表全部数据 和 与右表的交集部分，可以避免连接表时某些记录由于外键不存在，而查询不到。 1select 字段列表 from 表1 left outer join 表2 on 条件; -- outer可省略 上述例子添加一名新员工如下，他没有分配部门。若直接连接两张表查询所有员工的信息和部门，则该员工会因为 未分配部门 而查询不到，此时需要外连接。 1234-- 查询所有员工的信息和部门，若未分配部门，则该员工部门信息显示 nullSELECT t1.*, t2.nameFROM emp t1 LEFT OUTER JOIN dept t2 -- dept 左外连接 empON t1.dept_id = t2.id; 此时所有员工信息可正确查询。 &nbsp; 2. 右外连接：道理同左外连接，只是查询的是 查询的是 右表全部数据 和 与左表的交集部分。 123456select 字段列表 from 表1 right outer join 表2 on 条件; -- outer可省略-- 查询所有员工的信息和部门，若未分配部门，则该员工部门信息显示 nullSELECT t1.*, t2.nameFROM dept t2 RIGHT OUTER JOIN emp t1 -- dept 右外连接 empON t1.dept_id = t2.id; 子查询&nbsp; 1. 概念：查询中 嵌套查询，则嵌套的查询被称为子查询。 &nbsp; 2. 语法： 1234567select 字段列表from 表名where 条件1, ( -- ()内是子查询 select 字段列表 from 表名 where 条件) 条件2; &nbsp; 3. 子查询的不同情况 结果是 单行单列 的：子查询可以作为条件，使用运算符（=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;）去判断。如： 123456789-- 查询工资最高的员工信息-- 1. 查询工资最高是多少 2. 查询谁的工资是最高工资SELECT t1.*, t2.nameFROM emp t1, dept t2WHERE t1.dept_id = t2.id AND -- 连表t1.salary = ( -- 查询哪个人的工资等于最大工资 SELECT MAX(salary) -- 查询最大工资 FROM emp t1); 结果是 多行单列 的：子查询可以作为条件，使用运算符 IN 去判断。 12345678-- 查询财务部、市场部所有员工的信息-- 查询财务部、市场部所属的部门编号; 查询员工信息中，符合这些编号的员工SELECT * FROM empWHERE dept_id IN ( SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 结果是 多行多列 的：子查询可以作为一张 虚拟表。 123456789101112131415-- 查询入职日期是2011-11-11日之后的员工信息和部门信息-- 查询符合入职日期条件的员工，将其单独存入一张虚拟表，将虚拟表与部门信息表连接SELECT t2.*, t1.name FROM dept t1, ( SELECT * FROM emp WHERE join_date &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id;-- 普通内连接也可以实现SELECT t1.*, t2.name FROM emp t1, dept t2WHERE t1.dept_id = t2.id AND t1.join_date &gt; &apos;2011-11-11&apos;; 事务事务的基本介绍&nbsp; 1. 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么 同时成功，要么 同时失败。 &nbsp; 2. 操作： 开启事务 start transaction。 回滚 rollback。 提交 commit。 案例：现有表如下 id name balance 1 张三 1000 2 李四 1000 123456789START TRANSACTION; -- 开启事务-- 转账操作：张三账户-500，李四账户+500UPDATE account SET balance = balance - 500 WHERE NAME = &apos;张三&apos;;出错了... -- 人为bugUPDATE account SET balance = balance + 500 WHERE NAME = &apos;李四&apos;;COMMIT; -- 发现没有问题，提交事务ROLLBACK; -- 发现出问题，回滚事务，返回到事务开启的时候 &nbsp; 3. MySql 数据库中事务默认自动提交，一条 DML （增删改）语句会自动提交一次事务。 &nbsp; 4. 查看事务的默认提交方式：SELECT @@autocommit; -- 1代表自动提交，0代表手动提交 &nbsp; 5. 修改事务的默认提交方式：SET @@autocommit = 1/0; 事务的四大特征&nbsp; 1. 原子性：是不可分割的最小操作单位，同时成功 / 同时失败。&nbsp; 2. 持久性：当事务提交 / 回滚后，数据库会发生持久化的保存。&nbsp; 3. 隔离性：多个事务之间，相互独立。&nbsp; 4. 一致性：事务操作前后，数据总量不变。 事务的隔离级别 (了解)&nbsp; 1. 概念：多个事务之间是隔离的，相互独立。如果多个事务操作同一批数据，会引发一些问题，设置不同的隔离级别可以解决这些问题。 &nbsp; 2. 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据。 不可重复读（虚读）：同一个事务中，两次读取到的数据不一致。 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 &nbsp; 3. 隔离级别： read uncommitted： 读未提交，会产生上述三种问题。 read committed：（Oracle 默认）读已提交，解决 脏读 问题。 repeatable read：（MySQL 默认）可重复度，解决 脏读、不可重复读 问题。 serializable：串行化，解决 所有问题。 注意：隔离级别从小到大安全性回来越高，效率却越来越低。 &nbsp; 4. 数据库隔离级别相关的sql语句： 查询：12SELECT @@transaction_isolation; -- 查询数据库隔离级别（MySQL8.0以后版本）SELECT @@tx_isolation; -- MySQL 8.0 以前版本 设置：1set global transaction isolation level 级别字符串; -- 设置数据库隔离级别","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"计算机网络总结 —— 数据链路层","slug":"计算机网络总结 —— 数据链路层","date":"2019-11-09T10:52:47.000Z","updated":"2019-11-17T06:51:36.963Z","comments":true,"path":"2019/11/09/计算机网络总结 —— 数据链路层/","link":"","permalink":"http://yoursite.com/2019/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%20%E2%80%94%E2%80%94%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"前言&nbsp;&nbsp;&nbsp;&nbsp; 在 Java 开发计算机网络部分的知识中，最重要的就是 TCP/IP 协议栈，本系列将从 TCP/IP 协议体系的认知开始，详细讲解四层模型的各大协议及相关知识，突破面试。数据链路层篇内容为：TCP/IP协议体系、数据链路层的总结。","text":"前言&nbsp;&nbsp;&nbsp;&nbsp; 在 Java 开发计算机网络部分的知识中，最重要的就是 TCP/IP 协议栈，本系列将从 TCP/IP 协议体系的认知开始，详细讲解四层模型的各大协议及相关知识，突破面试。数据链路层篇内容为：TCP/IP协议体系、数据链路层的总结。 参考书籍 TCP/IP 详解 卷1：协议 计算机网络：自顶而下方法 TCP/IP 协议体系的认知&nbsp;&nbsp; 1. OSI 协议体系：OSI 协议按照功能不同，将互联网自下而上分成七层模型。 物理层：利用传输介质，为数据链路层提供物理连接。 传送内容为01序列的比特流，传输介质可以是光缆、电缆、双绞线、无线电波。 数据交换设备：集线器、中继器。 数据链路层：对物理层的电信号进行分组，解决两个相邻结点之间的通信问题，为网络层提供服务。 传送的协议数据单元： 数据帧。 数据交换设备： 网桥：将两个 LAN 连起来，根据 MAC 地址转发帧。 交换机：识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。 网络层：解决如何使数据包通过各结点传输的问题，即通过 路由选择算法 将数据包送往目的地，为传输层提供服务。 传送的协议数据单元： 数据包 或 分组。 数据交换设备： 路由器：路由转发、存储转发。 交换机 传输层：为上层协议提供 端到端 的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。 传送的协议数据单元：段。 数据交换设备：网关，在传输层以上实现网络互连，仅用于两个高层协议不同的网络互连，可以是局域网，也可以是广域网。 会话层：管理和协调不同主机上何种进程之间的通信(对话)，即负责建立、管理和中止应用程序之间的会话。 表示层：处理流经节点的数据编码的表示问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。 应用层：通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。是用户和网络的接口。 &nbsp;&nbsp;2. TCP/IP 协议体系：&nbsp;&nbsp;&nbsp;&nbsp; TCP/IP 协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层、应用层。每一层都用若干协议来实现不同的功能，上层协议使用下层协议提供的服务。 数据链路层：负责帧数据的传递，经过数据链路层封装的数据称为帧。 常用协议：ARP协议(地址解析协议)、RARP协议(反向地址解析协议)。 网络层：负责数据传递的方式，实现数据包的选路和转发。 常用协议：IP协议、ICMP协议。 传输层：负责传递数据的控制(准确性、安全性)，为两台主机上的应用程序提供 端到端 的通信，不在乎数据包的中转过程。 常用协议：TCP协议、UDP协议。 应用层：负责数据的展示和获取，如文件传输、名称查询和网络管理等。 常用协议：DNS协议、FTP协议、HTTP协议、HTTPS协议。 数据链路层&nbsp;&nbsp;&nbsp;&nbsp; 数据链路层，在物理层所提供的服务的基础上向网络层提供服务，即将原始的、有差错的物理线路改进成为逻辑上无差错的数据链路，从而向网络层提供高质量的服务。它一般包括 3 种基本服务：无确定的无连接服务、有确定的有连接服务、有确定的无连接服务（不存在无确定的有连接服务）。 以太网帧格式&nbsp;&nbsp;&nbsp;&nbsp; 以太网，是一种计算机局域网技术。IEEE 组织的 IEEE 802.3 标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。它采用 CSMA/CD 媒体接入方法，即带冲突检测的载波侦听多路接入，速率为 10 Mb/s，地址为 48 bit。分为 经典以太网 和 交换式以太网 两大类。 &nbsp;&nbsp;&nbsp;&nbsp; 由于以太网有很多标准，其数据帧格式也有很多，所以这里以 IEEE 802.3 标准来解析以太网帧格式。 字段 字段长度(字节) 说明 前导码(Preamble) 7 同步 帧开始符(SFD) 1 表名下一个字节为目的 MAC 字段 目的地址(DA) 6 目的设备的 MAC 物理地址 源地址(SA) 6 发送设备的 MAC 地址 长度/类型(Length/Type) 2 帧数据字段从长度 / 帧协议类型 数据及填充(data and pad) 46 ~ 1500 帧数据字段，来自高层数据 帧校验序列(FCS) 4 帧数据校验字段，若发生错误，则丢弃此帧 MTU 最大传输单元&nbsp;&nbsp;&nbsp;&nbsp; 以太网帧格式中，帧数据字段的长度被称为最大传输单元，即 MTU。它是指在传输数据过程中允许报文的最大长度，1500字节。 MTU 对 IP协议 的影响（1）IP报文在超过 MTU 之后需要分片，接收端需要组装。（2）分片若丢失，则接收端会组装失败，IP报文相当于传输失败，但IP协议不负责重新传输数据。（3）由于分片，会加大IP报文丢失的可能性。（4）报文的分片和组装由 IP层 独自完成，加大传输成本，降低性能。 MTU 对 UDP协议 的影响（1）UDP协议的报头为固定的 20 字节。（2）若 UDP 数据的长度超过 (1500 - 20) 1480 字节，则数据会在网络层分片。（3）数据的分片会加大数据丢失的可能性。 MTU 对 TCP协议 的影响（1）TCP协议的报头为 20 - 60 字节。（2）若 TCP 报文的总长度超过 1500 字节，则数据同样在网络层会分片。（3）数据分片会加大数据对视的可能性，TCP协议的可靠性降低。 &nbsp;&nbsp; 即由于MTU的存在，对于传输报文长度有限制而导致的分片，会增加数据丢包的可能性，也会降低数据传输的性能，所以在网络中传输数据时尽量将数据的大小控制在不造成分片的最大长度。 ARP 协议&nbsp;&nbsp;&nbsp;&nbsp; ARP协议是 地址解析协议 的缩写，由于在以太网环境中，数据传输所依赖的是 MAC 地址而不是 IP 地址，所以将已知 IP地址 转化为 MAC地址 的工作由 ARP 协议完成。 MAC地址 ：网络中每台设备都有一个唯一的网络标识，这个地址叫 MAC 地址，48 bit，表示为12个16进制数。 ARP 报文格式ARP的请求和应答都是依赖 ARP报文 结构进行的，它放在以太网数据帧中进行发送，下面是 ARP报文 的格式。其在以太网帧结构里封装的格式又为，即以太帧的数据区是ARP请求或响应的报文：在ARP表建立之前，主机并不知道目标的 MAC 地址，所以一开始时只能通过广播的方式将 ARP请求包 发送出去，处于统一局域网的主机都能接收到广播的数据包。 ARP 缓存&nbsp;&nbsp;&nbsp;&nbsp; ARP缓存是一个缓冲区，用来存储 IP地址到MAC地址的映射关系 ，每台主机或路由器都在维护着一个ARP缓存表。本质是 &lt;IP, MAC&gt;的对应表，表中一条记录就是网络上一个主机的 IP地址 和其对应的 MAC地址，我们称之为 ARP表项。 ARP缓存表包含一个 寿命值 TTL，也称作生存时间，它将记录每个 ARP表项的生存时间。生存时间到了就会从缓存表中删除。 当地址解析协议被询问一个已知 IP地址 结点的 MAC地址 时，先在 ARP缓存 中查看，存在则直接返回对应的 MAC地址；不存在，才发送 ARP 请求向局域网查询。 ARP 协议解析过程(查询过程) 每台主机都在自己的 ARP缓冲区 ，建立 ARP缓存表，表示IP地址和MAC地址的对应关系。源主机需要发送数据包时，先在 ARP缓存表 中查询，存在则发送，不存在则在局域网内发起 ARP请求 的广播包查询该 MAC地址。 网络中的 所有主机 收到ARP请求后，检查数据包中的IP地址是否和自己的IP地址一致，不相同忽略该数据包；相同则将 发送端的MAC地址和IP地址 添加到自己的ARP缓存表中，已存在则覆盖，然后向 源主机 发送一个 ARP响应包，告诉它本机的MAC地址。 源主机收到该响应数据包，将 目的主机的MAC地址和IP地址 添加到自己的ARP缓存表中，并利用该信息进行数据传输。如果源主机 没有收到ARP响应数据包，则表示查询失败。 RARP 协议&nbsp;&nbsp;&nbsp;&nbsp; RARP协议，又称反向地址转换协议，可以理解为ARP协议的逆过程，即 将MAC地址转化为IP地址。RARP分组的格式和ARP分组基本一致，工作流程也基本一致，这里就不再详细叙述。 面试题总结 问题1：ARP的作用？答：ARP可以将 IP地址 转化为 MAC地址，即为IP地址到对应的硬件地址提供 动态映射。 问题2：点对点链路使用ARP吗？答：不使用，因为点对点链路的通信双方 已获知彼此的IP地址，不需要ARP协议进行转换。 问题3：ARP高效运行的关键是？答：每台主机都维护着一张 ARP缓存表，ARP地址解析时首先查看的是本主机的 ARP缓存表，发现没有时，再向局域网内广播查询。 问题4：ARP报文的各个字段及含义？答：字段如ARP报文结构图，共28字节，记忆方法：以太网先目的后源，ARP先发送端后目的端，先硬件后协议。 问题5：ARP协议有什么弱点？答：（1）缓存：主机的地址映射是基于缓存表，动态更新的，而地址刷新有 时间限制。可以通过下次更新之前修改计算机的地址缓存，造成 DDos攻击 或 ARP欺骗。（2）广播：攻击者可以伪装 ARP应答。（3）ARP应答没有认证，都是合法的。可以在不接受请求的时候就发出应答包。 问题6：ARP代理的概念和应用场景答：ARP代理：若ARP请求是从一个网络的主机，发送到 另一个网络的主机，那么连接这个两个网络的路由器就可以回答该请求，该过程是ARP代理。ARP代理路由器响应ARP请求的MAC地址为 路由器的MAC地址，而不是ARP请求主机的MAC地址。应用场景：两个物理网络之间的路由，使用相等的网络号，两个路由器使用 ARP 代理，实现相互隐瞒物理网络。 问题7：免费ARP是什么？答：免费ARP：指主机发送 ARP 查找 自己的IP地址，即数据链路层 SIP = DIP。作用：（1）确定是否有其他主机设置了与本机相同的IP地址。（2）如果本机更改MAC地址，可以告知其他主机更新ARP缓存表。 书签TCP/IP协议族体系结构ARP协议详解数据链路层：ARP协议详解（绝对经典）","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"Java自学路线及书籍推荐","slug":"Java自学路线及书籍推荐","date":"2019-11-05T07:12:17.000Z","updated":"2019-11-12T14:04:53.234Z","comments":true,"path":"2019/11/05/Java自学路线及书籍推荐/","link":"","permalink":"http://yoursite.com/2019/11/05/Java%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF%E5%8F%8A%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/","excerpt":"基础知识 编程语言：Java Java编程思想， Python， C 基本算法 基本网络知识：TCP/IP， HTTP/HTTPS。 TCP/IP 详解 基本设计模式","text":"基础知识 编程语言：Java Java编程思想， Python， C 基本算法 基本网络知识：TCP/IP， HTTP/HTTPS。 TCP/IP 详解 基本设计模式 工具 操作系统：Linux(CentOS\\Ubuntu\\Fedora) 代码管理：SVN / Git 持续集成(CI/CD)：jenkins Java项目管理工具：Maven / Gradle 框架方面应用层框架 SSH：Spring + Structs + Hibernate，已过时不建议学 SSM：Spring + SpringMVC + Mybatis。 JavaEE框架整合开发入门到实战，这本书讲究入门使用，原理讲的并不深入。 Spring Boot 中间件 MQ 消息队列 RPC 通信框架：gRPC thrift dubbo SpringCloud ElasticSearch 数据库 搜索引擎 数据库 SQL：MySQL / Postgre SQL NoSQL：Redis Memcached MongoDB 架构方面分布式 / 微服务架构 Spring Cloud Dubbo RPC 通信框架 虚拟化 / 容器化技术 Docker 容器化 K8S：kubernetes 关注源码 / 性能 JDK 源码以及部分设计思想 Spring 源码 JVM 细节与排错：深入理解Java虚拟机 高并发 / 高可用：Java并发编程实战，Java并发编程的艺术","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Windows系统下Hexo博客搭建","slug":"Windows系统下Hexo博客搭建","date":"2019-11-05T03:50:26.000Z","updated":"2019-11-13T17:54:07.744Z","comments":true,"path":"2019/11/05/Windows系统下Hexo博客搭建/","link":"","permalink":"http://yoursite.com/2019/11/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"前言Hexo 使一个快速简洁的博客框架，可以非常容易搭建起自己的博客，在平时学习工作中便于及时记录知识要点并分享。本文将记录 Windows 系统下 Hexo 博客搭建的流程，帮助更多人搭建个人博客。","text":"前言Hexo 使一个快速简洁的博客框架，可以非常容易搭建起自己的博客，在平时学习工作中便于及时记录知识要点并分享。本文将记录 Windows 系统下 Hexo 博客搭建的流程，帮助更多人搭建个人博客。 Hexo 搭建步骤 安装 Node.js 安装 Git 安装 Hexo 在 Github 中创建个人仓库 将 Hexo 部署到 Github 发布文章 更换 Hexo 主题 安装 Node.js在 Node.js 官网，可以下载到最新版本，当前是 12.13.0。具体安装教程可以参考 Node.js安装及环境配置之Windows篇，需要特别注意环境变量的设置。 安装 Git同样在 Git 官网的下载页面，可以下载 Linux、Windows、mac OS 三个版本的安装包，点击 windows 下载，安装在本地磁盘中。安装完成，点击鼠标右键，若出现 Git GUI Here 和 Git Bash Here，则下载安装成功。后续操作全部在 Git Bash 下执行。 安装 Hexo&nbsp;&nbsp; 1. 首先在任意磁盘新建文件夹 MyBlog，用来统一管理博客。然后在该文件夹下打开 Git Bash，使用命令安装 Hexo，并检查是否安装成功。 12npm i -g hexo # 安装 hexohexo -v # 检查 hexo 的版本 &nbsp;&nbsp; 2. 初始化 Hexo。 1hexo init &nbsp;&nbsp; 3. 启动 Hexo 本地服务，可以得知服务运行在 http://localhost:4000 上，我们可以通过该网址在本地访问博客。 1hexo s &nbsp;&nbsp; 4. 创建一篇博客，文章保存在 /MyBlog/source/_posts，博客内容使用 Markdown 语法编写，这里推荐一款专门编写 Hexo 博客的编辑器 HexoEditor，源项目 可以在 Github 上查看，也可以 直接下载 发布版本。 1hexo n &quot;文章名称&quot; &nbsp;&nbsp; 5. 博客编辑完成后，退回至 /MyBlog 文件夹下，使用命令 清空 缓存文件和已经生成的静态文件，然后生成静态文件，从本地进行访问。 12hexo clean # 清空缓存hexo g # 生成静态文件 在 Github 中创建个人仓库&nbsp;&nbsp; 1. 首先在 Github 上创建一个新仓库，以如下格式命名： 12&quot;GitHub_ID&quot;.github.io # 命名格式ID-Wanwan.github.io # 我的GitHub id是 ID-Wanwan， &nbsp;&nbsp; 2. 现在需要将本地博客与 Github 建立关联。在根目录 /MyBlog 下打开 Git Bash，安装插件 hexo-deployer-git。 1npm install hexo-deployer-git --save &nbsp;&nbsp; 3. 根目录中有博客配置文件 _config.yml，用文本编辑器打开配置文件，在 # Deployment 下的 deploy 属性中添加如下内容： 1234deploy: type: git repo: https://github.com/ID-Wanwan/ID-Wanwan.github.io.git branch: master 其中 repo 是步骤1中 新建仓库的地址 ，后面再加上 .git 即可。到此本地博客就与 Github 建立了关联，可以进行下一步部署。 将 Hexo 部署在 Github 上&nbsp;&nbsp; 1. 输入部署命令： 1hexo d 发现出现 Erroe: Spawn failed，根据提示，发现需要设置 Github 的邮箱和用户名信息，来帮助辨认身份并登录到远端的个人仓库。 12git config --global user.email &quot;you@example.com&quot; # 设置 Github 邮箱git config --global user.name &quot;Your Name&quot; # 设置 Github 用户名 重新设置完成后，再次输入部署命令 hexo d，然后输入账号密码登录 Github 。 &nbsp;&nbsp; 2. 若运行过程中发现如下错误： 1error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 根据查阅资料得知，这是安全设置的问题，解决方式如下： * 首先执行： git config http.sslVerify &quot;false&quot; * 若发现如下错误：fatal：not in a git directory * 执行：git config --globle http.sslVerify &quot;false&quot; 经过如上步骤，再次部署博客 hexo d，Github 仓库中就有刚才发布的博客了。 &nbsp;&nbsp; 3. 在浏览器中输入 Github 博客仓库的名称，即可远端访问博客，部署完成。 1https://ID-Wanwan.github.io 发布文章&nbsp;&nbsp; 1. 通过 hexo n &quot;文章名称&quot;，创建一篇新的博客，用文本编辑器编辑文章。&nbsp;&nbsp; 2. 在本地预览博客发布后的样式。 123hexo clean # 清空缓存 hexo g # 生成静态文件hexo s # 启动本地服务 &nbsp;&nbsp; 3. 确认无误后，将博客发布到 Github 平台。 1hexo d 更换 Hexo 主题&nbsp;&nbsp; 1. 在 Github 或者 Hexo 官网上寻找自己喜欢的博客主题，这里以在 Github 中下载 yilia 主题为例。在本地博客根目录 /MyBlog 下打开 Git Bash，可以以如下格式下载主题： 12git clone 主题链接.git themes/主题文件夹 # 参考格式git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia &nbsp;&nbsp; 2. 在 /MyBlog/themes 中可以看到刚才下载好的主题， 退回到根目录 /MyBlog，打开配置文件 _config.yml，在 # Extensions 下更改 theme 的值为主题文件夹的名称。 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia &nbsp;&nbsp; 3. 更新设置，在本地预览。 123hexo clean # 清空缓存 hexo g # 生成静态文件hexo s # 启动本地服务 &nbsp;&nbsp; 4. 确认无误后，部署至 Github 平台，主题更换完成。 1hexo d 后记到这里个人博客就已经初步搭建成功，后续可以根据自己的需要更改主题的美化设置，深入探索 Hexo 框架或者其他博客框架的其他内容。 书签HexoEditor 快捷键","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]}